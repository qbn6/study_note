# 第10章_索引优化与查询优化

**Author**: `GaoFy`

**Reference**: `shk`

**Date**: `2022-06-16`

---

都有哪些维度可以进行数据库调优？简言之：

- 索引失效，没有充分利用到索引——索引建立
- 关联查询太多`JOIN`（设计缺陷或不得已的需求）——`SQL`优化
- 服务器调优及各个参数设置（缓冲、线程数等）——调整`my.cnf`
- 数据过多——分库分表

关于数据库调优的知识点非常分散。不同的`DBMS`，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。

虽然`SQL`查询优化的技术有很多，但是大方向上完全可以分成==物理查询优化==和==逻辑查询优化==两大块。

- 物理查询优化是通过==索引==和==表连接方式==等技术来进行优化，这里重点需要掌握索引的使用。
- 逻辑查询优化就是通过`SQL`==等价交换==提升查询效率，直白说，换一种查询写法执行效率可能更高。

## 1.数据准备

---

==学员表==插`50万`条，==班级表==插`1万`条。

**步骤1：建表**

```mysql
create table class(
	id int not null auto_increment,
    className varchar(30) default null,
    address varchar(40) default null,
    monitor int null,
    primary key(id)
);

create table student(
	id int not null auto_increment,
    stuno int not null,
    `name` varchar(20) default null,
    age int default null,
    classId int default null,
    primary key(id)
);
```

**步骤2：参数设置**

命令开启：允许创建函数设置：

```mysql
set global log_bin_trust_function_creators = 1;
```

**步骤3：创建函数**

保证每条数据都不同

```mysql
# 随机生成字符串
delimiter //

create function rand_string(n int)
returns varchar(255)
begin
	declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	declare return_str varchar(255) default '';
	declare i int default 0;
	
	while i < n do
		set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));
		set i = i + 1;
	end while;
	
	return return_str;
end //

delimiter ;
```

随机产生班级编号

```mysql
# 用于随机产生多少到多少的编号
delimiter //

create function rand_num(from_num int, to_num int)
returns int
begin
	declare i int default 0;
	set i = floor(from_num+rand()*(to_num - from_num+1));
	return i;
end //

delimiter ;
```

**步骤4：创建存储过程**

```mysql
# 创建往student表中插入数据的存储过程
delimiter //

create procedure insert_stu(`start` int, max_num int)
begin
	declare i int default 0;
	set autocommit = 0;
	
	repeat
		set i = i + 1;
		insert into student(stuno, `name`, age, classId) values
		((`start`+1),rand_string(6),rand_num(1,50),rand_num(1,1000));
	until i = max_num
	end repeat;
	
	commit;
end //

delimiter ;
```

```mysql
# 创建往class表中插入数据的存储过程
delimiter //

create procedure insert_class(max_num int)
begin
	declare i int default 0;
	set autocommit = 0;
	
	repeat
		set i = i + 1;
		insert into class(classname, address, monitor) values
		(rand_string(8), rand_string(10), rand_num(1,100000));
	until i = max_num
	end repeat;
	
	commit;
end //

delimiter ;
```

**步骤5：调用存储过程**

```mysql
call insert_class(10000);
call insert_stu(100000,500000);
```

**步骤6：删除某表上的索引**

创建存储过程

```mysql
delimiter //

create procedure proc_drop_index(dbname varchar(200), tablename varchar(200))
begin
	declare done int default 0;
	declare ct int default 0;
	declare _index varchar(200) default '';
	
	declare _cur cursor for
	select index_name from information_schema.STATISTICS
	where table_schema=dbname and `table_name`=tablename and seq_in_index=1 and index_name <> 'PRIMARY';
	# 每个游标必须使用不同的declare continue handler for not found set done = 1来控制游标的结束
	declare continue handler for not found set done = 2;
	# 若没有数据返回，程序继续，并将变量done设为2
	open _cur;
	fetch _cur into _index;
	
	while _index <> '' do
		set @str = concat("drop index ", _index, " on ", `tablename`);
		prepare sql_str from @str;
		execute sql_str;
		deallocate prepare sql_str;
		set _index = '';
		fetch _cur into _index;
	end while;
	
	close _cur;
end //

delimiter ;
```

## 2.索引失效案例

---

`MySQL`中==提高性能==的一个最有效的方式是对数据表==设计合理的索引==。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

- 使用索引可以==快速地定位==表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。
- 如果查询时没有使用索引，查询语句就会==扫描表中的所有记录==。在数据量大的情况下，这样查询的速度会很慢。

大多数情况下都（默认）采用`B+Tree`来构建索引。只是空间列类型的索引使用`R-Tree`，并且`MEMORY`表还支持`Hash`索引。

其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于`cost开销(CostBaseOptimizer)`，它不是基于`规则（Rule-BasedOptimizer）`，也不是基于==语义==。怎么样开销小就怎么来。另外，**`SQL`语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系**。

### 2.1 全值匹配我最爱

系统中经常出现的`SQL`语句如下：

```mysql
explain select sql_no_cache * from student where age = 30;
explain select sql_no_cache * from student where age = 30 and classId = 4;
explain select sql_no_cache * from student where age = 30 and classId = 4 and `name` = 'abcd';
```

建立索引前执行：（关注执行时间）

```mysql
mysql> select sql_no_cache * from student where age = 30 and classId = 4 and `name` = 'abcd';
Empty set, 1 warning (0.15 sec)
```

**建立索引**

```mysql
create index idx_age on student(age);
create index idx_age_classid on student(age, classId);
create index idx_age_classid_name on student(age, classId, `name`);
```

建立索引后执行：

```mysql
mysql> select sql_no_cache * from student where age = 30 and classId = 4 and `name` = 'abcd';
Empty set, 1 warning (0.00 sec)
```

可以看到，创建索引前的查询时间为`0.15`秒，创建索引后的查询时间是`0.00`秒，索引帮助我们极大的提高了查询效率。

### 2.2 最佳左前缀法则

在`MySQL`建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

举例1：

```mysql
explain select sql_no_cache * from student where age = 30 and `name` = 'abcd';
```

举例2：

```mysql
explain select sql_no_cache * from student where classId = 1 and `name` = 'abcd';
```

举例3：**索引`idx_age_classid_name`还能否正常使用？**

```mysql
explain select * from student where classId = 4 and age = 30 and `name` = 'abcd';
```

如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。

```mysql
explain select * from student where age = 30 and `name` = 'abcd';
```

![image-20220616185419178](第10章_索引优化与查询优化.assets\image-20220616185419178.png)

虽然可以正常使用，但是只有部分被使用到了。

```mysql
explain select * from student where classId = 1 and `name` = 'abcd';
```

![image-20220616184027899](第10章_索引优化与查询优化.assets\image-20220616184027899.png)

完全没有使用上索引。

结论：`MySQL`可以为多个字段创建索引，一个索引可以包括`16`个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用**。如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。

> **拓展：`Alibaba`《Java开发手册》**
>
> 索引文件具有`B-Tree`的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

### 2.3 主键插入顺序

对于一个使用`InnoDB`存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在==聚簇索引==的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录==主键值从小到大==的顺序进行排序，所以如果==插入==的记录的==主键值是依次增大==的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的==主键值忽大忽小==的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在`1-100`之间：

![image-20220616185943377](第10章_索引优化与查询优化.assets\image-20220616185943377.png)

如果此时再插入一条主键值为`9`的记录，那它插入的位置就如下图：

![image-20220616190131971](第10章_索引优化与查询优化.assets\image-20220616190131971.png)

可这个数据页已经满了，再插入咋办呢？需要把当前==页面分裂==成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：==性能损耗==！所以如果想尽量避免这样无谓的性能损耗，最好让插入的记录的==主键值依次递增==，这样就不会发生这样的性能损耗了。所以建议：让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入，比如：`person_info`表：

```mysql
create table person_info(
	id int unsigned not null auto_increment,
    `name` varchar(100) not null,
    birthday date not null,
    phone_number char(11) not null,
    country varchar(100) not null,
    primary key(id),
    key idx_name_birthday_phone_number (`name`(10),birthday,phone_number)
);
```

自定义主键列`id`拥有`AUTO_INCREMENT`属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。

### 2.4 计算、函数导致索引失效

1. 这两条`SQL`哪种写法更好

```mysql
explain select * from student where `name` like 'abc%';

explain select * from student where left(`name`, 3) = 'abc';
```

2. 创建索引

```mysql
create index idx_name on student(`name`);
```

3. 第一种：索引优化生效

```mysql
explain select * from student where `name` like 'abc%';
```

![image-20220616193036579](第10章_索引优化与查询优化.assets\image-20220616193036579.png)

`type`为"range"，表示有使用到索引。

第二种：索引优化失效

```mysql
explain select * from student where left(`name`, 3) = 'abc';
```

![image-20220616193151638](第10章_索引优化与查询优化.assets\image-20220616193151638.png)

`type`为"ALL"，表示没有使用到索引，查询时间为`3.62`秒，查询效率之前低很多。

**再举例**：

- `student`表的字段`stuno`上设置有索引

```mysql
create index idx_sno on student(stuno);
```

- 索引优化失效：（假设`student`表的字段`stuno`上设置有索引）

```mysql
explain select id, stuno, `name` from student where stuno + 1 = 900001;
```

运行结果：

![image-20220616194051001](第10章_索引优化与查询优化.assets\image-20220616194051001.png)

如果对索引进行了表达式计算，索引就会失效了。这是因为需要把索引字段的值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是==全表扫描==的方式，运行时间也会慢很多，最终运行时间为`2.538`秒。

- 索引优化生效：

```mysql
explain select id, stuno, `name` from student where stuno = 900000;
```

**再举例**：

- `student`表的字段`name`上设置有索引

```mysql
create index idx_name on student(`name`);
```

想要对`name`的前三位为`abc`的内容进行条件筛选。

- 索引优化失效：

```mysql
explain select id, stuno, `name` from student where substring(`name`, 1, 3) = 'abc';
```

![image-20220616194615619](第10章_索引优化与查询优化.assets\image-20220616194615619.png)

- 索引优化生效：

```mysql
explain select id, stuno, `name` from student where `name` like 'abc%';
```

![image-20220616194700174](第10章_索引优化与查询优化.assets\image-20220616194700174.png)

查询重写后，可以使用索引进行范围检索，从而提升查询效率。

### 2.5 类型转换导致索引失效

下列哪个`SQL`语句可以用到索引。（假设`name`字段上设置有索引）

```mysql
# 未使用上索引
explain select * from student where `name` = 123;
```

![image-20220616194852292](第10章_索引优化与查询优化.assets\image-20220616194852292.png)

```mysql
# 使用到索引
explain select * from student where `name` = '123';
```

![image-20220616195117508](第10章_索引优化与查询优化.assets\image-20220616195117508.png)

`name=123`发生了类型转换，索引失效。

> 结论：设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类型转换的情况。

### 2.6 范围条件右边的列索引失效

1. 如果系统经常出现的`SQL`如下：

```mysql
alter table student drop index idx_name;
drop index idx_age on student;
drop index idx_age_classid on student;
```

```mysql
explain select * from student
where age = 30 and classId > 20 and `name` = 'abc';
```

![image-20220616195735643](第10章_索引优化与查询优化.assets\image-20220616195735643.png)

2. 那么索引`idx_age_classid_name`这个索引还能正常使用吗？

   - 不能，范围右边的列不能使用。比如：（<）（<=）（>）（>=）和`between`等

   - 如果这种`SQL`出现较多，应该建立：

     ```mysql
     create index idx_age_name_classid on student(age, `name`, classId);
     ```

   - 将范围查询条件放置语句最后：

     ```mysql
     explain select * from student where age = 30 and `name` = 'abc' and classId > 20;
     ```

   > 应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询，应将查询条件放置`where`语句最后。（创建的联合索引中，务必把范围涉及到的字段写到最后）

3. `idx_age_name_classid`效果

```mysql
explain select * from student where age = 30 and classId > 20 and `name` = 'abc';
```

![image-20220616200654249](第10章_索引优化与查询优化.assets\image-20220616200654249.png)

### 2.7 不等于（`!=`或者`<>`）索引失效

- 为`name`字段创建索引

```mysql
create index idx_name on student(`name`);
```

- 查看索引是否失效

```mysql
explain select * from student where `name` <> 'abc';
# 或
explain select * from student where `name` != 'abc';
```

![image-20220616201009271](第10章_索引优化与查询优化.assets\image-20220616201009271.png)

场景举例：用户提出需求，将财务数据，产品利润金额不等于0的都统计出来。

### 2.8`is null`可以使用索引，`is not null`无法使用索引

- `IS NULL`：可以触发索引

```mysql
explain select * from student where age is null;
```

![image-20220616201553391](第10章_索引优化与查询优化.assets\image-20220616201553391.png)

- `IS NOT NULL`：无法触发索引

```mysql
explain select * from student where age is not null;
```

![image-20220616201807559](第10章_索引优化与查询优化.assets\image-20220616201807559.png)

> 结论：最好在设计数据表的时候就将==字段设置为"NOT NULL"约束==，比如可以将`INT`类型的字段，默认值设置为`0`，将字符类型的默认值设置为空字符串`''`。
>
> 拓展：同理，在查询中使用`NOT LIKE`页无法使用索引，导致全表扫描。

### 2.9 like以通配符%开头索引失效

在使用`LIKE`关键字进行查询的查询语句中，如果匹配字符串的第一个字符为"%"，索引就不会起作用。只有"%"不在第一个位置，索引才会起作用。

- 使用到索引

```mysql
explain select * from student where `name` like 'ab%';
```

![image-20220616202122249](第10章_索引优化与查询优化.assets\image-20220616202122249.png)

- 未使用到索引

```mysql
explain select * from student where `name` like '%ab%';
```

![image-20220616202325056](第10章_索引优化与查询优化.assets\image-20220616202325056.png)

> **拓展：`Alibaba`《Java开发手册》**
>
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

### 2.10 OR 前后存在非索引的列，索引失效

在`WHERE`子句中，如果在`OR`前的条件列进行了索引，而在`OR`后的条件列没有进行索引，那么索引会失效。也就是说，**`OR`前后的两个条件中的列都是索引时，查询中才使用索引**。

因为`OR`的含义就是两个只要满足一个即可，因此==只有一个条件列进行了索引是没有意义的==。只要有条件列没有进行索引，都会进行==全表扫描==，因此索引的条件列也会失效。

查询语句使用`OR`关键字的情况：

```mysql
# 未使用列索引
explain select * from student where age = 10 or classId = 100;
```

![image-20220616203213507](第10章_索引优化与查询优化.assets\image-20220616203213507.png)

因为`calssId`字段上没有索引，所以上述查询语句没有使用索引。

```mysql
# 使用列索引
explain select * from student where age = 10 or `name` = 'Abel';
```

![image-20220616203347907](第10章_索引优化与查询优化.assets\image-20220616203347907.png)

因为`age`字段和`name`字段上都有索引，所以查询中使用了索引。简单来说`index_merge`就是对`age`和`name`分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是==避免了全表扫描==。

### 2.11 数据库和表的字符集统一使用utf8mb4

统一使用`utf8mb4`（`5.53`版本以上支持）兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的==字符集==进行比较前需要进行==转换==会造成索引失效。

### 2.12 练习以及一般性建议

**练习**：假设`index(a, b, c)`

| where语句                                           | 索引是否被使用                                               |
| --------------------------------------------------- | ------------------------------------------------------------ |
| where a = 3                                         | Y，使用到了a                                                 |
| where a = 3 and b = 5                               | Y，使用到了a, b                                              |
| where a = 3 and b = 5 and c = 4                     | Y，使用到了a, b, c                                           |
| where b = 3 或 where b = 3 and c = 4 或 where c = 4 | N                                                            |
| where a = 3 and c = 5                               | 使用到了a，但是c不可以，b中间断了                            |
| where a = 3 and b > 4 and c = 5                     | 使用到了a和b，c不能用在范围之后，b断了                       |
| where a is null and b is not null                   | is null 支持索引，但是 is not null 不支持，所以a可以使用索引，但是b不可以使用 |
| where a <> 3                                        | N                                                            |
| where abs(a) = 3                                    | N                                                            |
| `where a = 3 and b like 'kk%' and c = 4`            | Y，使用到了a, b, c                                           |
| where a = 3 and b like ‘%kk’ and c = 4              | Y，使用到了a                                                 |
| where a = 3 and b like ‘%kk%’ and c = 4             | Y，使用到了a                                                 |
| `where a = 3 and b like 'k%kk%' and c = 4`          | Y，使用到了a, b, c                                           |

**一般性建议**：

- 对于单列索引，尽量选择针对当前`query`过滤性更好的索引。
- 在选择组合索引的时候，当前`query`中过滤性最好的字段在索引字段顺序中，位置越靠前越好。

- 在选择组合索引的时候，尽量选择能够包含当前`query`中的`where`子句中更多字段的索引。
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

**总之，书写`SQL`语句时，尽量避免造成索引失效的情况**。

## 3.关联查询优化

---

### 3.1 数据准备

```mysql
# 分类
create table if not exists `type`(
	id int unsigned not null auto_increment,
    card int unsigned not null,
    primary key(id)
);

# 图书
create table if not exists book(
	bookid int unsigned not null auto_increment,
    card int unsigned not null,
    primary key(bookid)
);
```

```mysql
create procedure insert_type_and_book()
begin
	declare num int default 0;
	
	repeat
		set num = num + 1;
		
		set autocommit = 0;
		
		insert into type(card) values(floor(1+(rand()*20)));
		insert into book(card) values(floor(1+(rand()*20)));
	until num = 20
	end repeat;
	
	commit;
end;
```

### 3.2 采用左外连接

```mysql
explain select * from `type` left join book on `type`.card = book.card;
```

![image-20220617121126273](第10章_索引优化与查询优化.assets\image-20220617121126273.png)

结论：`type`有`ALL`

添加索引优化

```mysql
create index Y on book(card); #【被驱动表】，可以避免全表扫描

explain select * from `type` left join book on `type`.card = book.card;
```

![image-20220617122200587](第10章_索引优化与查询优化.assets\image-20220617122200587.png)

可以看到第二行的`type`变成了`ref`，`rows`也变成了`1`，优化比较明显。这是由左连接特性决定的。`LETF JOIN`条件用于确定如何从右表搜索行，左边一定都有，所以==右边是我们的关键点，一定需要建立索引==。

```mysql
create index X on `type`(card); # 【驱动表】，无法避免全表扫描

explain select * from `type` left join book on `type`.card = book.card;
```

![image-20220617152746947](第10章_索引优化与查询优化.assets\image-20220617152746947.png)

接着：

```mysql
drop index Y on book;

explain select * from `type` left join book on `type`.card = book.card;
```

![image-20220617152900097](第10章_索引优化与查询优化.assets\image-20220617152900097.png)

### 3.3 采用内连接

```mysql
drop index X on `type`;
```

换成`inner join`（`MySQL`自动选择驱动表）

```mysql
explain select * from `type` join book on `type`.card = book.card;
```

![image-20220617153040748](第10章_索引优化与查询优化.assets\image-20220617153040748.png)

添加索引优化

```mysql
create index Y on book(card);

explain select * from `type` join book on `type`.card = book.card;
```

![image-20220617153134200](第10章_索引优化与查询优化.assets\image-20220617153134200.png)

```mysql
create index X on `type`(card);

explain select * from `type` join book on `type`.card = book.card;
```

![image-20220617160137619](第10章_索引优化与查询优化.assets\image-20220617160137619.png)

接着：

```mysql
drop index Y on `book`;

explain select * from `type` join book on `type`.card = book.card;
```

![image-20220617160328008](第10章_索引优化与查询优化.assets\image-20220617160328008.png)

接着：

```mysql
# 再向type表插入20条数据
create procedure insert_type()
begin
	declare num int default 0;
	
	repeat
		set num = num + 1;
		
		set autocommit = 0;
		
		insert into type(card) values(floor(1+(rand()*20)));
	until num = 20
	end repeat;
	
	commit;
end;
```

```mysql
explain select * from `type` join book on `type`.card = book.card;
```

![image-20220617161659150](第10章_索引优化与查询优化.assets\image-20220617161659150.png)

图中发现，由于`type`表数据大于`book`表数据，`MySQL`选择将`type`作为被驱动表。

> 本人（`GaoFy`）所见，当大表（type）没有索引，而小表（book）有索引的情况下，大表（type）会成为驱动表。
>
> 总结：当双表要么都有索引要么都没索引，小表驱动大表。当单表具有索引，有索引的表为被驱动表，无索引的表为驱动表。

![image-20220617162050371](第10章_索引优化与查询优化.assets\image-20220617162050371.png)

### 3.4 join语句原理

`join`方式连接多个表，本质就是各个表之间数据的循环匹配。`MySQL 5.5`版本之前，`MySQL`只支持一种表间关联方式，就是嵌套循环（Nested Loop Join）。如果关联表的数据量越大，则`join`关联的执行时间就越长。在`MySQL 5.5`以后的版本中，`MySQL`通过引入`BNLJ`算法来优化嵌套执行。

#### 1.驱动表和被驱动表

驱动表就是主表，被驱动表就是从表，非驱动表。

- **对于内连接来说**：

```mysql
select * from A join B on ...
```

`A`一定是驱动表吗？不一定，优化器会根据查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过`explain`关键字可以查看。

- **对于外连接来说**：

```mysql
select * from A left join B on ...
# 或
select * from B right join A on ...
```

通常，大家会认为`A`就是驱动表，`B`就是被驱动表，但也未必。测试如下：

```mysql
create table a(f1 int, f2 int, index(f1));
create table b(f1 int, f2 int);

insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);

# 测试1
explain select * from a left join b on a.f1 = b.f1 where a.f2 = b.f2; # 由于where的存在，左外连接失效，变为内连接
# 测试2
explain select * from a left join b on a.f1 = b.f1 and a.f2 = b.f2;
```

![image-20220617165207937](第10章_索引优化与查询优化.assets\image-20220617165207937.png)

#### 2.Simple Nested-Loop Join（简单嵌套循环连接）

从表`A`中取出一条数据`1`，遍历表`B`，将匹配到的数据放到`result..`依次类推，驱动表`A`中的每一条记录与被驱动表`B`的记录进行判断：

![image-20220617165416858](第10章_索引优化与查询优化.assets\image-20220617165416858.png)

可以看到这种方式效率是非常低的，以上述表`A`数据`100`条，表`B`数据`1000`条计算，则`A*B=10万次`。开销统计如下：

| 开销统计         | SNLJ  |
| ---------------- | ----- |
| 外表扫描次数     | 1     |
| 内表扫描次数     | A     |
| 读取记录数       | A+B*A |
| JOIN比较次数     | B*A   |
| 回表读取记录次数 | 0     |

当然`MySQL`肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对`Nested-Loop Join`优化算法。

#### 3.Index Nested-Loop Join（索引嵌套循环连接）

`Index Nested-Loop Join`其优化的思路主要是为了==减少内层表数据的匹配次数==，所以要求被驱动表上必须==有索引==才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。

![image-20220617170613080](第10章_索引优化与查询优化.assets\image-20220617170613080.png)

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故`MySQL`优化器都倾向于使用记录数少的表作为驱动表（外表）。

| 开销统计         | SNLJ  | INLJ                  |
| ---------------- | ----- | --------------------- |
| 外表扫描次数     | 1     | 1                     |
| 内表扫描次数     | A     | 0                     |
| 读取记录数       | A+B*A | A+B(match)            |
| JOIN比较次数     | B*A   | A*index(Height)       |
| 回表读取记录次数 | 0     | B(match)(if possible) |

如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。

#### 4.Block Nested-Loop Join（块嵌套循环连接）

如果存在索引，那么会使用`index`的方式进行`join`，如果`join`的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了`I/O`的次数。为了减少被驱动表的`I/O`次数，就出现了`Block Nested-Loop Join`的方式。

不再是逐条获取驱动表的数据，而是一块一块的获取，引入了`join buffer缓冲区`，将驱动表`join`相关的部分数据列（大小受`join buffer`的限制）缓存到`join buffer`中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和`join buffer`中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。

> 注意：
>
> 这里缓存的不只是关联表的列，`SELECT`后面的列也会缓存起来。
>
> 在一个有`N`个`join`关联的`SQL`中会分配`N-1`个`join buffer`。所以查询的时候尽量减少不必要的字段，可以让`join buffer`中可以存放更多的列。

![image-20220617172816763](第10章_索引优化与查询优化.assets\image-20220617172816763.png)

| 开销统计         | SNLJ  | INLJ                  | BNLJ                                        |
| ---------------- | ----- | --------------------- | ------------------------------------------- |
| 外表扫描次数     | 1     | 1                     | 1                                           |
| 内表扫描次数     | A     | 0                     | A*used_column_size/join_buffer_size+1       |
| 读取记录数       | A+B*A | A+B(match)            | A+B\*(A\*used_column_size/join_buffer_size) |
| JOIN比较次数     | B*A   | A*index(Height)       | B*A                                         |
| 回表读取记录次数 | 0     | B(match)(if possible) | 0                                           |

参数设置：

- `block_nested_loop`

通过`show variables like '%optimizer_switch%'`查看`block_nested_loop`状态。默认是开启的。

- `join_buffer_size`

驱动表能不能一次加载完，要看`join buffer`能不能存储所有的数据，默认情况下`join_buffer_size=256k`。

```mysql
mysql> show variables like '%join_buffer%';
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| join_buffer_size | 262144 |
+------------------+--------+
1 row in set (0.00 sec)
```

`join_buffer_size`的最大值在32位系统可以申请4G，而在64位操作系统下可以申请大于4G的`join buffer`空间（64位`Windows`除外，其大值会被截断为`4GB`并发出警告）。

#### 5.Join小结

**1.整体效率比较：`INLJ > BNLJ > SNLJ`**

2.永远用小结果集驱动大结果集（其实本质就是减少外层循环的数据量）（小的度量单位指的是 表行数*每行大小）

```mysql
select t1.b,t2.* from t1 straight_join t2 on t1.b = t2.b where t2.id <= 100; # 推荐

select t1.b,t2.* from t2 straight_join t1 on t1.b = t2.b where t2.id <= 100; # 不推荐
```

3.为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数）

4.增大`join buffer size`的大小（一次缓存的数据越多，那么内层的扫表次数就越少）

5.减少驱动表不必要的字段查询（字段越少，`join buffer`所缓存的数据就越多）

#### 6.Hash Join

**从`MySQL`的`8.0.20`版本开始将废弃`BNLJ`，因为从`MySQL 8.0.18`版本就加入了`hash join`，默认都会使用`hash join`**。

- `Nested Loop`：

对于被连接的数据子集较小的情况，`Nested Loop`是个较好的选择。

- `Hash Join`是做==大数据集连接==时的常用方式，优化器使用两个表中较小（相对较小）的表利用`Join Key`在内存中建立==散列表==，然后扫描较大的表并探测散列表，找出与`Hash`表匹配的行。
  - 这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问这两个表的成本之和。
  - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成==若干不同的分区==，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高`I/O`的性能。
  - 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是`Join`的重型升降机。`Hash Join`只能应用于等值连接（如`WHERE A.COL1 = B.COL2`），这是由`Hash`的特点决定的。

| 类型     | Nested Loop                                                  | Hash Join                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用条件 | 任何条件                                                     | 等值连接（=）                                                |
| 相关资源 | CPU、磁盘I/O                                                 | 内存、临时空间                                               |
| 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，那能够快速返回第一次的搜索结果。 | 当缺乏索引或者索引条件模糊时，`Hash Join`比`Nested Loop`有效。在数据仓库环境下，如果表的记录较多，效率高。 |
| 缺点     | 当索引丢失或查询条件限制不够时，效率很低；当表的记录数多时，效率低。 | 为建立哈希表，需要大量内存。第一次的结果返回较慢。           |

## 4.子查询优化

---

`MySQL`从`4.1`版本开始支持子查询，使用子查询可以进行`SELECT`语句的嵌套查询，即一个`SELECT`查询的结果作为另一个`SELECT`语句的条件。==子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作==。

**子查询是`MySQL`的一项最重要的功能，可以帮助我们通过一个`SQL`语句实现比较复杂的查询。但是，子查询的执行效率不高**。原因：

① 执行子查询时，`MySQL`需要为内层查询语句的查询结果==建立一个临时表==，然后外层查询语句从临时表中查询记录。查询完毕后，再==撤销这些临时表==。这样会消耗过多的`CPU`和`IO`资源，产生大量的慢查询。

② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都==不会存在索引==，所以查询性能会受到一定的影响。

③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

**在`MySQL`中，可以使用连接（JOIN）查询来替代子查询**。连接查询==不需要建立临时表==，其==速度比子查询要快==，如果查询中使用索引的话，性能就会更好。

举例1：查询学生表中是班长的学生信息

- 使用子查询

```mysql
create index idx_monitor on class(monitor);

explain select * from student stu1
where stu1.stuno in (
						select monitor
    					from class c
    					where monitor is not null
					);
```

- 推荐：使用多表查询

```mysql
explain select stu1.* from student stu1 join class c
on stu1.stuno = c.monitor
where c.monitor is not null;
```

举例2：取所有不为班长的同学

- 不推荐

```mysql
explain select a.*
from student a
where a.stuno not in (
						select monitor from class b
    					where monitor is not null
					 );
```

![image-20220617183848773](第10章_索引优化与查询优化.assets\image-20220617183848773.png)

推荐：

```mysql
explain select a.*
from student a left join class b
on a.stuno = b.monitor
where b.monitor is null;
```

![image-20220617184114732](第10章_索引优化与查询优化.assets\image-20220617184114732.png)

> 结论：尽量不要使用`NOT IN`或者`NOT EXISTS`，用`LEFT JOIN xxx ON xxx WHERE xx IS NULL`替代。

## 5.排序优化

---

### 5.1 排序优化

**问题**：在`WHERE`条件字段上加索引，但是为什么`ORDER BY`字段是还要加索引呢？

**回答**：

在`MySQL`中，支持两种排序方式，分别是`FileSort`和`Index`排序。

- `Index`排序中，索引可以保证数据的有序性，不需要再进行排序，==效率更高==。
- `FileSort`排序则一般在==内存中==进行排序，占用`CPU较多`。如果待排结果较大，会产生临时文件`I/O`到磁盘进行排序的情况，效率较低。

**优化建议**：

1. `SQL`中，可以在`WHERE`子句和`ORDER BY`子句中使用索引，目的是在`WHERE`子句中==避免全表扫描==，在`ORDER BY`子句==避免使用FileSort排序==。当然，某些情况下全表扫描，或者`FileSort`排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。

2. 尽量使用`Index`完成`ORDER BY`排序。如果`WHERE`和`ORDER BY`后面是相同的列就使用单索引列；如果不同就使用联合索引。
3. 无法使用`Index`时，需要对`FileSort`方式进行调优。

### 5.2 测试

删除`student`表和`class`表中已创建的非主键索引。

以下是否能使用到索引，==能否去掉using filesort==

**过程一**：

```mysql
explain select * from student order by age, classid;
```

![image-20220617190230117](第10章_索引优化与查询优化.assets\image-20220617190230117.png)

```mysql
explain select * from student order by age, classid limit 10;
```

![image-20220617190628302](第10章_索引优化与查询优化.assets\image-20220617190628302.png)

**过程二：`order by`时不`limit`，索引失效**

```mysql
create index idx_age_classid_name on student(age, classid, `name`);

explain select * from student order by age, classid;
```

![image-20220617190859506](第10章_索引优化与查询优化.assets\image-20220617190859506.png)

```mysql
# 增加limit过滤条件，使用上索引了。
explain select * from student order by age, classid limit 10;
```

![image-20220617191248279](第10章_索引优化与查询优化.assets\image-20220617191248279.png)

**过程三：`order by`时排序错误，索引失效**

```mysql
create index idx_age_classid_stuno on student(age, classid, stuno);

# 以下哪些索引失效？
explain select * from student order by classid limit 10;

explain select * from student order by classid, `name` limit 10;

explain select * from student order by age, classid, stuno limit 10;

explain select * from student order by age, classid limit 10;

explain select * from student order by age limit 10;
```

分别的：

```mysql
explain select * from student order by classid limit 10;
```

![image-20220617192919952](第10章_索引优化与查询优化.assets\image-20220617192919952.png)

```mysql
explain select * from student order by classid, `name` limit 10;
```

![image-20220617192942274](第10章_索引优化与查询优化.assets\image-20220617192942274.png)

```mysql
explain select * from student order by age, classid, stuno limit 10;
```

![image-20220617193005744](第10章_索引优化与查询优化.assets\image-20220617193005744.png)

```mysql
explain select * from student order by age, classid limit 10;
```

![image-20220617193036589](第10章_索引优化与查询优化.assets\image-20220617193036589.png)

```mysql
explain select * from student order by age limit 10;
```

![image-20220617193055295](第10章_索引优化与查询优化.assets\image-20220617193055295.png)

**过程四：`order by`时规则不一致，索引失效（顺序错，不索引；方向反，不索引）**

```mysql
explain select * from student order by age desc, classid asc limit 10;

explain select * from student order by classid desc, `name` desc limit 10;

explain select * from student order by age asc, classid desc limit 10;

explain select * from student order by age desc, classid desc limit 10;
```

分别的：

```mysql
explain select * from student order by age desc, classid asc limit 10;
```

![image-20220617193331286](第10章_索引优化与查询优化.assets\image-20220617193331286.png)

```mysql
explain select * from student order by classid desc, `name` desc limit 10;
```

![image-20220617193359088](第10章_索引优化与查询优化.assets\image-20220617193359088.png)

```mysql
explain select * from student order by age asc, classid desc limit 10;
```

![image-20220617193417959](第10章_索引优化与查询优化.assets\image-20220617193417959.png)

```mysql
explain select * from student order by age desc, classid desc limit 10;
```

![image-20220617193435981](第10章_索引优化与查询优化.assets\image-20220617193435981.png)

**过程五：无过滤，不索引**

```mysql
explain select * from student where age = 45 order by classid;

explain select * from student where age = 45 order by classid, name;

explain select * from student where classid = 45 order by age;

explain select * from student where classid = 45 order by age limit 10;
```

分别的：

```mysql
explain select * from student where age = 45 order by classid;
```

![image-20220617193909129](第10章_索引优化与查询优化.assets\image-20220617193909129.png)

```mysql
explain select * from student where age = 45 order by classid, name;
```

![image-20220617193928610](第10章_索引优化与查询优化.assets\image-20220617193928610.png)

```mysql
explain select * from student where classid = 45 order by age;
```

![image-20220617194419593](第10章_索引优化与查询优化.assets\image-20220617194419593.png)

```mysql
explain select * from student where classid = 45 order by age limit 10;
```

![image-20220617194434653](第10章_索引优化与查询优化.assets\image-20220617194434653.png)

**小结**：

```mysql
index a_b_c(a, b, c)

order by 能使用索引最左前缀
- order by a
- order by a, b
- order by a, b, c
- order by a desc, b desc, c desc

如果 WHERE 使用索引的最左前缀定义为常量，则 order by 能使用索引
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b = const ORDER BY c
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b = const ORDER BY b, c

不能使用索引进行排序
- ORDER BY a ASC, b DESC, c DESC /* 排序不一致 */
- WHERE g = const ORDER BY b, c  /* 丢失a索引 */
- WHERE a = const ORDER BY c     /* 丢失b索引 */
- WHERE a = const ORDER BY a, d  /* d不是索引的一部分 */
- WHERE a in (...) ORDER BY b, c /* 对于排序来说，多个相等条件也是范围查询 */
```

### 5.3 案例实战

`ORDER BY`子句，尽量使用`index`方式排序，避免使用`FileSort`方式排序。

执行案例前先清除`student`上的索引，只留主键：

```mysql
call proc_drop_index('atguigudb2', 'student');
```

**场景：查询年龄为`30`岁的，且学生编号小于`101000`的学生，按用户名称排序**

```mysql
explain select * from student where age = 30 and stuno < 101000 order by `name`;
```

![image-20220617195638757](第10章_索引优化与查询优化.assets\image-20220617195638757.png)

> 结论：`types`是`ALL`，即最坏的情况。`Exra`里还出现了`Using filesort`也是最坏的情况。优化是必须的。

优化思路：

**方案一：为了去掉`filesort`我们可以把索引建成**

```mysql
# 创建新索引
create index idx_age_name on student(age, `name`);
```

![image-20220617200802261](第10章_索引优化与查询优化.assets\image-20220617200802261.png)

查询结果如下：

![image-20220617201110109](第10章_索引优化与查询优化.assets\image-20220617201110109.png)

这样我们优化掉了`using filesort`。

**方案二：尽量让`where`的过滤条件和排序使用上索引**

建一个三个字段的组合索引：

```mysql
drop index idx_age_name on student;

create index idx_gae_stuno_name on student(age, stuno, `name`);

explain select * from student where age = 30 and stuno < 101000 order by `name`;
```

![image-20220617200711407](第10章_索引优化与查询优化.assets\image-20220617200711407.png)

发现`using filesort`依然存在，所以`name`并没有用到索引，而且`type`还是`range`，光看字面其实并不美好，原因是，因为`stuno是一个范围过滤`，所以索引后面的字段不会再使用索引了。

![image-20220617201202675](第10章_索引优化与查询优化.assets\image-20220617201202675.png)

结果竟然有`filesort`的`SQL`运行速度与上面不分上下。

原因：

所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的`stuno<101000`这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。

> 结论：
>
> 1. 两个索引同时存在，`MySQL`自动选择最优的方案。（对于这个例子，`MySQL`选择`idx_age_stuno_name`）。但是，==随着数据量的变化，选择的索引也会随之发生变化==。
> 2. **当【范围条件】和【`group by`或者`order by`】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。**

思考：这里使用如下索引，是否可行?

```mysql
drop index idx_age_stuno_name on student;

create index idx_age_stuno on student(age, stuno);
```

### 5.4 filesort算法：双路排序和单路排序

排序的字段若如果不在索引列上，则`filesort`会有两种算法：**双路排序**和**单路排序**

**双路排序（慢）**

- ==MySQL 4.1 之前是使用双路排序==，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和`order by`列，对它们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。

- 从磁盘取排序字段，在`buffer`进行排序，再从==磁盘取其他字段==。

取一批数据，要对磁盘进行两次扫描，众所周知，`I/O`是很耗时的，所以在`MySQL 4.1`之后，出现了第二种改进的算法，就是单路排序。

**单路排序（快）**

从磁盘读取查询需要的所有列，按照`order by`列在`buffer`对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机`I/O`变成了顺序`I/O`，但是它会使用更多的空间，因为它把每一行都保存在内存中了。

**结论及引申出的问题**

- 由于单路是后出的，总体而言好过双路
- 但是用单路有问题
  - 在`sort_buffer`中，单路比多路要==多占用很多空间==，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了`sort_buffer`的容量，导致每次只能取`sort_buffer`容量大小的数据，进行排序（创建`tmp`文件，多路合并），排完再取`sort_buffer`容量大小，再排......从而多次`I/O`。
  - 单路本来想省一次`I/O`操作，==反而导致了大量的I/O操作==，反而得不偿失。

**优化策略**

**1.尝试提高`sort_buffer_size`**

- 不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的`1M~8M`之间调整。`MySQL 5.7`，`InnoDB`存储引擎默认值是`1048576字节`，`1MB`。

```mysql
mysql> show variables like '%sort_buffer_size%';
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| innodb_sort_buffer_size | 1048576 |
| myisam_sort_buffer_size | 8388608 |
| sort_buffer_size        | 262144  |
+-------------------------+---------+
3 rows in set (0.00 sec)
```

**2.尝试提高`max_length_for_sort_data`**

- 提高这个参数，会增加用改进算法的概率。

```mysql
mysql> show variables like '%max_length_for_sort_data%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| max_length_for_sort_data | 4096  |
+--------------------------+-------+
1 row in set (0.00 sec)
```

- 但是如果设的太高，数据总容量超出`sort_buffer_size`的概率就增大，明显症状是高的磁盘`I/O`活动和低的处理器使用率。如果需要返回的列的总长度大于`max_length_for_sort_data`，使用双路算法，否则使用单路算法。`1024-8192`字节之间调整。

**3.`Order by`是`select *`是一个大忌，最好只`Query`需要的字段**。原因：

- 当`Query`的字段大小综合小于`max_length_for_sort_data`，而且排序字段不是`TEXT|BLOB`类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。

- 两种算法的数据都由可能超过`sort_buffer_size`的容量，超出之后，会创建`tmp`文件进行合并排序，导致多次`I/O`，但是用单路排序算法的风险会更大一些，所以要提高`sort_buffer_size`。

## 6.GROUP BY优化

---

- `group by`使用索引的原则几乎跟`order by`一致，`group by`即使没有过滤条件用到索引，也可以直接使用索引。
- `group by`先排序后分组，遵循索引建的最佳左前缀法则。
- 当无法使用索引列，增大`max_length_for_sort_data`和`sort_buffer_size`参数的设置。
- `where`效率高于`having`，能写在`where`限定的条件就不要写在`having`中了。
- 减少使用`order by`，和业务沟通能不排序就不排序，或将排序放到程序段去做。`Order by`、`group by`、`distinct`这些语句较为耗费`CPU`，数据库的`CPU`资源是极其宝贵的。
- 包含了`order by`、`group by`、`distinct`这些查询的语句，`where`条件过滤出来的结果集请保持在`1000`行以内，否则`SQL`会变慢。

## 7.优化分页查询

---

一般分页查询时，通过创建覆盖索引能够比较好的提高性能。一个常见又非常头疼的问题就是`limit 2000000,10`，此时需要`MySQL`排序前`2000010`记录，仅仅返回`2000000-2000010`的记录，其他记录丢弃，查询排序的代价非常大。

```mysql
explain select * from student limit 2000000, 10;
```

![image-20220617221429815](第10章_索引优化与查询优化.assets\image-20220617221429815.png)

**优化思路一**

在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。

```mysql
explain select * 
from student t, (select id from student order by id limit 2000000,10) a
where t.id = a.id;
```

![image-20220617221644143](第10章_索引优化与查询优化.assets\image-20220617221644143.png)

**优化思路二**

该方案适用于主键自增的表，可以把`LIMIT`查询转换成某个位置的查询。

```mysql
explain select * from student where id > 2000000 limit 10;
```

![image-20220617221827727](第10章_索引优化与查询优化.assets\image-20220617221827727.png)

## 8.优先考虑覆盖索引

---

### 8.1 什么是覆盖索引？

**理解方式一**：索引是最高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。**一个索引包含了满足查询结果的数据就叫做覆盖索引**。

**理解方式二**：非聚簇符合索引的一种形式，它包括在查询里的`SELECT`、`JOIN`和`WHERE`子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。

简单来说，==索引列+主键==包含==SELECT 列 FROM 之间查询的列==。

**举例一**：

```mysql
create index idx_age_name on student(age, `name`);

explain select * from student where age <> 20;
```

![image-20220617223500193](第10章_索引优化与查询优化.assets\image-20220617223500193.png)

```mysql
explain select id,age,`name` from student where age <> 20;
```

![image-20220617223651277](第10章_索引优化与查询优化.assets\image-20220617223651277.png)

上述都使用到了声明的索引，下面的情况则不然，在查询列中多了一列`classid`，显示未使用到索引

```mysql
explain select id, age, `name`, classid from student where age <> 20;
```

![image-20220617224357238](第10章_索引优化与查询优化.assets\image-20220617224357238.png)

**举例二**：

```mysql
explain select * from student where `name` like '%abc';
```

![image-20220617224448828](第10章_索引优化与查询优化.assets\image-20220617224448828.png)

```mysql
explain select id, age, `name` from student where `name` like '%abc';
```

![image-20220617224609070](第10章_索引优化与查询优化.assets\image-20220617224609070.png)

上述都使用到了声明的索引，下面的情况则不然，查询列依然多了`classid`，结果是未使用到索引：

```mysql
explain select id, age, `name`, classid from student where `name` like '%abc';
```

![image-20220617224750534](第10章_索引优化与查询优化.assets\image-20220617224750534.png)

### 8.2 覆盖索引的利弊

**好处**：

**1.避免`Innodb`表进行索引的二次查询（回表）**

`InnoDB`是以聚簇索引的顺序来存储的，对于`InnoDB`来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，==避免了对主键的二次查询，减少了IO操作==，提升了查询效率。

**2.可以把随机`I/O`变成顺序`I/O`加快查询效率**

由于覆盖索引是按键值的顺序存储的，对于`I/O`密集型的范围查找来说，对比随机从磁盘读取每一行的数据`I/O`要少很多，因此利用覆盖索引在访问时页可以把磁盘的==随机读取的IO==转变成索引查找的==顺序IO==。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**。

**弊端**：

==索引字段的维护==总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务`DBA`，或称为业务数据架构师的工作。

## ~~9.如何给字符串添加索引~~（康师傅未录）

---

有一张教师表，表定义如下：

> 从查询效率上看，使用`hash`字段方式的查询性能相对更稳定一些。因为`crc32`算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1，而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。

## 10.索引下推

---

### 10.1 使用前后对比

`Index Condition Pushdown(ICP)`是`MySQL 5.6`中新特性，是一种在存储引擎层使用索引过滤数据的优化方式。

- 如果没有`ICP`，存储引擎会遍历索引以定位基表中的行，并将它们返回给`MySQL`服务器，由`MySQL`服务器评估`WHERE`后面的条件是否保留行。
- 启用`ICP`后，如果部分`WHERE`条件可以仅使用索引中的列进行筛选，则`MySQL`服务器会把这部分`WHERE`条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。
  - 好处：`ICP`可以减少存储引擎必须访问基表的次数和`MySQL`服务器必须访问存储引擎的次数。
  - 但是，`ICP`的==加速效果==取决于在存储引擎内通过==ICP筛选==掉的数据的比例。

### 10.2 ICP的开启/关闭

- 默认情况下启用索引条件下推。可以通过设置系统变量`optimizer_switch`控制：`index_condition_pushdown`

```mysql
# 打开索引下推
set optimizer_switch = 'index_condition_pushdown=on';
# 关闭索引下推
set optimizer_switch = 'index_condition_pushdown=off';
```

- 当使用索引条件下推时，`EXPLAIN`语句输出结果中`Extra`列内容显示为`Using index condition`。

### 10.3 ICP使用案例

建表

```mysql
create table people(
	id int not null auto_increment,
    zipcode varchar(20),
    firstname varchar(20),
    lastname varchar(20),
    address varchar(50),
    primary key(id),
    key zip_last_first(zipcode, lastname, firstname)
)engine=innodb auto_increment=5 default charset=utf8mb3 collate=utf8_bin;
```

插入数据

```mysql
insert into people values
(1, '000001', '二', '张', '北京市'),
(2, '000002', '四', '李', '南京市'),
(3, '000003', '五', '王', '上海市'),
(4, '000004', '六', '赵', '天津市');
```

为该表定义联合索引`zip_last_first(zipcode, lastname, firstname)`。如果我们知道一个人的邮编，但是不确定这个人的姓氏，可以进行如下检索：

```mysql
explain select * from people 
where zipcode = '000001' and lastname like '%张%' and address like '%北京市%';
```

执行查看`SQL`的查询计划，`Extra`中显示了`Using index condition`，这表示使用了**索引下推**。另外，`Using where`表示条件中包含需要过滤的非索引列的数据，即`address LIKE '%北京市%'`这个条件并不是索引列，需要在服务端过滤掉。

![image-20220617235133762](第10章_索引优化与查询优化.assets\image-20220617235133762.png)

如果不想出现`Using where`，把`address like '%北京市%'`去掉即可

![image-20220618000419520](第10章_索引优化与查询优化.assets\image-20220618000419520.png)

这个表中存在两个索引，分别是：

- 主键索引（简图）

  ![image-20220618000548197](第10章_索引优化与查询优化.assets\image-20220618000548197.png)

  二级索引`zip_last_first`（简图，这里省略了数据页等信息）

  ![image-20220618000605501](第10章_索引优化与查询优化.assets\image-20220618000605501.png)

下面我们关闭`ICP`查看执行计划

```mysql
set optimizer_switch = 'index_condition_pushdown=off';
```

查看执行计划，已经没有了`Using index condition`，表示没有使用`ICP`

```mysql
explain select * from people 
where zipcode = '000001' and lastname like '%张%' and address like '%北京市%';
```

![image-20220618000806533](第10章_索引优化与查询优化.assets\image-20220618000806533.png)

### 10.4 开启和关闭ICP的性能对比

创建存储过程，主要目的就是插入很多`000001`的数据，这样查询的时候为了在存储引擎层做过滤，减少`I/O`，也为了减少缓冲池（缓存数据页，没有`I/O`）的作用。

```mysql
delimiter //

create procedure insert_people(max_num int)
begin
	declare i int default 0;
	
	set autocommit = 0;
	
	repeat
		set i = i + 1;
		insert into people(zipcode, firstname, lastname, address)
		values ('000001', '六', '赵', '天津市');
	until i = max_num
	end repeat;
	
	commit;
end //

delimiter ;
```

调用存储过程

```mysql
call insert_people(1000000);
```

首先打开`profiling`。

```mysql
set profiling = 1;
```

执行`SQL`语句，此时默认打开索引下推。

```mysql
select * from people where zipcode = '000001' and lastname like '%张%';
```

再次执行`SQL`语句，不使用索引下推

```mysql
select /*+ no_icp (people) */ * from people where zipcode = '000001' and lastname like '%张%';
```

查看当前会话所产生的所有`profiles`

```mysql
show profiles;
```

![image-20220618002127715](第10章_索引优化与查询优化.assets\image-20220618002127715.png)

多次测试效率对比来看，使用`ICP`优化的查询效率会好一些。这里建议多存储一些数据效果更明显。

### 10.5 ICP的使用条件

1. 如果表访问的类型为`range`、`ref`、`eq_ref`和`ref_or_null`可以使用`ICP`
2. `ICP`可以用于`InnoDB`和`MyISAM`表，包括分区表`InnoDB`和`MyISAM`表
3. 对于`InnoDB`表，`ICP`仅用于==二级索引==。`ICP`的目标是减少全行读取次数，从而减少`I/O`操作
4. 当`SQL`使用覆盖索引时，不支持`ICP`。因为这种情况下使用`ICP`不会减少`I/O`
5. 相关子查询的条件不能使用`ICP`

## ~~11.普通索引 vs 唯一索引~~（康师傅未录）

---

3. 如果所有的更新后面，都马上==伴随着对这个记录的查询==，那么你应该==关闭change buffer==。而在其他情况下，`change buffer`都能提升更新性能。
4. 由于唯一索引用不上`change buffer`的优化机制，因此如果==业务可以接受==，从性能角度出发建议优先考虑非唯一索引。但是如果"业务可能无法确保"的情况下，怎么处理呢？
   - 首先，==业务正确性优先==。我们的前提是"业务代码已经保证不会写入重复数据"的情况下，讨论性能问题。如果业务不能保证，或业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你躲提供一个排查思路。
   - 然后，在一些"==归档库=="的场景，是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。

## 12. 其他查询优化策略

---

### 12.1 EXISTS 和 IN 的区分

**问题**：

不太理解哪种情况下应该使用`EXISTS`，哪种情况用`IN`。选择的标准是看能否使用表的索引吗？

**回答**：

索引是个前提，其实选择与否还是要看表的大小，可以将选择的标准理解为==小表驱动大表==。在这种方式下效率是最高的。

比如下面这样：

```mysql
select * from A where cc in (select cc from B);

select * from A where exists (select cc from B where B.cc = A.cc);
```

当`A`小于`B`时，用`EXISTS`。因为`EXISTS`的实现，相当于外表循环，实现的逻辑类似于：

```mysql
for i in A
	for j in B
		if j.cc == i.cc then ...
```

当`B`小于`A`时用`IN`，因为实现的逻辑类似于：

```mysql
for i in B
	for j in A
		if j.cc == i.cc then ...
```

哪个表小就用哪个表来驱动，A表小就用`EXISTS`，B表小就用`IN`。

### 12.2 COUNT(*)与COUNT(具体字段)效率

问：在`MySQL`中统计数据表的行数，可以使用三种方式：`SELECT COUNT(*)`、`SELECT COUNT(1)`和`SELECT COUNT(具体字段)`，使用这三者之间的查询效率是怎样的？

答：

前提：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。

**环节1**：`COUNT(*)`和`COUNT(1)`都是对所有结果进行`COUNT`，`COUNT(*)`和`COUNT(1)`本质上并没有区别（二者执行时间可能略有差别，不过还是可以把它俩的执行效率看成是相等的）。如果有`WHERE`子句，则是对所有符合筛选条件的数据行进行统计；如果没有`WHERE`子句，则是对数据表的数据行数进行统计。

**环节2**：如果是`MyISAM`存储引擎，统计数据表的行数只需要`O(1)`的复杂度，这是因为每张`MyISAM`的数据表都有一个`meta`信息存储了`row_count`值，而一致性则由表级锁来保证。

如果是`InnoDB`存储引擎，因为`InnoDB`支持事务，采用行级锁和`MVCC`机制，所以无法像`MyISAM`一样，维护一个`row_count`变量，因此需要采用==扫描全表==，是`O(n)`的复杂度，进行循环+计数的方式来完成统计。

环节3：在`InnoDB`引擎中，如果采用`COUNT(具体字段)`来统计数据行数，要尽量采用二级索引，因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于`COUNT(*)`和`COUNT(1)`来说，它们不需要查找具体的行，只是统计行数，系统会==自动==采用占用空间更小的二级索引来进行统计。

如果有多个二级索引，会使用`key_len`小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

### 12.3 关于 SELECT *

在表查询中，建议明确字段，不要使用`*`作为查询的字段列表，推荐使用`SELECT <字段列表>`查询。原因：

① `MySQL`在解析的过程中，会通过==查询数据字典==将"*"按序转换成所有列名，这会大大的耗费资源和时间。

② 无法使用==覆盖索引==。

### 12.4 LIMIT 1 对优化的影响

针对的是会扫描全表的`SQL`语句，如果可以确定结果集只有1条，那么加上`LIMIT 1`的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

如果数据表已经对字段创建了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上`LIMIT 1`了。

### 12.5 多使用COMMIT

只要有可能，在程序中尽量多使用`COMMIT`，这样程序的性能得到提高，需求也会因为`COMMIT`所释放的资源而减少。

`COMMIT`所释放的资源：

- 回滚段上用于恢复数据的信息
- 被程序语句获得的锁
- `redo/undo log buffer`中的空间
- 管理上述3种资源中的内部花费

## 13.淘宝数据库，主键如何设计的？

---

聊一个实际问题：淘宝的数据库，主键是如何设计的？

大部分人的答案如此自信：用8字节的`BIGINT`做主键，而不要用`INT`。==错！==

这样的回答，只站在了数据库这一层，而没有==从业务的角度==思考主键。主键就是一个自增ID吗？站在`2022`年的新年档口，用自增做主键，架构设计上可能==连及格都拿不到==。

### 13.1 自增ID的问题

自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题：

**1，可靠性不高**

存在自增ID回溯的问题，这个问题直到最新版本的`MySQL 8.0`才修复。

**2.安全性不高**

对外暴露的接口可以非常容易猜测对应的信息。比如`/Usr/1`这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。

**3.性能差**

自增ID的性能较差，需要在数据库服务器端生成。

**4.交互多**

业务还需要额外执行一次类似`last_insert_id()`的函数才知道刚才插入的自增值，这需要多一次的网络交互，在海量并发的系统中，多1条`SQL`，就多一次性能上的开销。

**5.局部唯一性**

最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。

### 13.2 业务字段做主键

为了能够唯一地标识一个会员的信息，需要为==会员信息表==设置一个主键。那么，怎么为这个表设置主键，才能达到理想的目标呢？这里考虑业务字段做主键。

表数据如下：

![image-20220618103234281](第10章_索引优化与查询优化.assets\image-20220618103234281.png)

在这个表里，哪个字段比较合适呢？

- **选择卡号（cardno）**

会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。

```mysql
create table demo.membermaster(
	cardno char(8) primary key,
    membername text,
    memberphone text,
    memberpid text,
    memberaddress text,
    sex text,
    birthday datetime
);
```

不同的会员卡号对应不同的会员，字段"cardno"唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。

但实际情况是，==会员卡号可能存在重复使用==的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了（退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号是`10000001`的会员卡发给了王五。

从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是"10000001"这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是"10000001"的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现"有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息，而导致系统内部数据不一致"的情况。因此，从==信息系统层面==上看是没问题的。

但是从使用==系统的业务层面==来看，就有很大的问题了，会对商家造成影响。

比如，我们有一个消费流水表（trans），记录了所有的销售流水明细。2020年12月01日，张三在门店购买了一本书，消费了89元。那么，系统中就有了张三买书的流水记录，如下所示：

![image-20220618104242492](第10章_索引优化与查询优化.assets\image-20220618104242492.png)

接着，查看一下2020年12月01日的会员消费记录：

```mysql
select b.membername, c.goodsname, a.quantity, a.salesvalue, a.transdate
from demo.trans as a
join demo.membermaster as b
join demo.goodsmaster as c
on a.cardno = b.cardno and a.itemnumber = c.itemnumber;
+------------+-----------+----------+------------+---------------------+
| membername | goodsname | quantity | salesvalue | transdate           |
+------------+-----------+----------+------------+---------------------+
| 张三       | 书        | 1.000    | 89.00      | 2020-12-01 00:00:00 |
+------------+-----------+----------+------------+---------------------+
1 row in set (0.00 sec)
```

如果会员卡"10000001"又发给了王五，我们就要更改会员信息表。导致查询时：

```mysql
select b.membername, c.goodsname, a.quantity, a.salesvalue, a.transdate
from demo.trans as a
join demo.membermaster as b
join demo.goodsmaster as c
on a.cardno = b.cardno and a.itemnumber = c.itemnumber;
+------------+-----------+----------+------------+---------------------+
| membername | goodsname | quantity | salesvalue | transdate           |
+------------+-----------+----------+------------+---------------------+
| 王五       | 书        | 1.000    | 89.00      | 2020-12-01 00:00:00 |
+------------+-----------+----------+------------+---------------------+
1 row in set (0.01 sec)
```

这次得到的结果是：王五在2020年12月01日，买了一本书，消费89元。显然是错误的！结论：千万不能把会员卡号当做主键。

- **选择会员电话 或 身份证号**

会员电话可以做主键嘛？不行的。在实际操作中，手机号页存在==被运营商回收==，重新发给别人用的情况。

那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于==个人隐私==，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。

**所以，建议尽量不要用跟服务有关的字段做主键。毕竟，作为项目设计的技术人员，谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现**。

> 经验：
>
> 刚开始使用`MySQL`时，很多人多很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。

### 13.3 淘宝的主键设计

在淘宝的电商业务中，订单服务是一个核心业务。请问，==订单表的主键==淘宝是如何设计的呢？是自增ID吗？打开淘宝，看一下订单信息：

![image-20220618105932642](第10章_索引优化与查询优化.assets\image-20220618105932642.png)

从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：

`1550672064762308113`

`1481195847180308113`

`1431156171142308113`

`1431146631521308113`

订单号是19位的长度，且订单的最后5为都是一样的，都是`08113`。且订单号的前`14`位部分是单调递增的。

大胆猜测，淘宝的订单ID设计应该是：

`订单ID = 时间 + 去重字段 + 用户ID后6位尾号`

这样的设计能做到全局唯一，且对分布式系统查询及其友好。

### 13.4 推荐的主键设计

==非核心业务==：对应表的主键自增ID，如警告、日志、监控等信息。

==核心业务==：**主键设计至少应该是全局唯一且是单调递增**。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。

这里推荐最简单的一种主键设计：`UUID`

**`UUID`的特点**：

全局唯一，占用36字节，数据无序，插入性能差。

**认识`UUID`**：

- 为什么`UUID`是全局唯一的？
- 为什么`UUID`占用36个字节？
- 为什么`UUID`是无序的？

`MySQL`数据库的`UUID`组成如下所示：

`UUID = 时间 + UUID版本（16字节） - 时钟序列（4字节） - MAC地址（12字节）`

以`UUID`值`e0ea12d4-6473-11eb-943c-00155dbaa39d`举例：

![image-20220618111022366](第10章_索引优化与查询优化.assets\image-20220618111022366.png)

==为什么UUID是全局唯一的==？

在`UUID`中时间部分占用`60`位，存储的类似`TIMESTAMP`的时间戳，但表示的是从`1582-10-15 00:00:00`到现在的`100ns`的计数。可以看到`UUID`存储的时间精度比`TIMESTAMP`更高，时间维度发生重复的概率降低到`1/100ns`。时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。`MAC`地址用于全局唯一。

==为什么UUID占用36个字节==？

`UUID`根据字符串进行存储，设计时还带有无用"-"字符串，因此总共需要36个字节。

==为什么UUID是随机无序的呢==？

因为`UUID`的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。

**改造UUID**

若将时间高低位互换，则时间就是单调递增的了，整体就是单调递增的了。`MySQL 8.0`可以更换时间低位和时间高位的存储方式，这样`UUID`就是有序的`UUID`了。

`MySQL 8.0`还解决了`UUID`存在的空间占用的问题，除去了`UUID`字符串中无意义的"-"字符串，并且将字符串用二进制类型保存，这样存储空间降低为了`16`字节。

可以通过`MySQL 8.0`提供的`uuid_to_bin`函数实现上述功能，同样的，`MySQL`也提供了`bin_to_uuid`函数进行转化：

```mysql
set @uuid = UUID();

select @uuid, uuid_to_bin(@uuid), uuid_to_bin(@uuid,TRUE);
```

![image-20220618112446603](第10章_索引优化与查询优化.assets\image-20220618112446603.png)

**通过函数`uuid_to_bin(@uuid, true)`将UUID转化为有序UUID**了。全局唯一+单调递增，这不就是我们想要的主键！

**4.有序UUID性能测试**

`16`字节的有序`UUID`，相比之前`8`字节的自增ID，性能和存储空间对比究竟如何呢？

做一个测试，插入1亿条数据，每条数据占用`500`字节，含有3个二级索引，最终的结果如下所示：

![image-20220618113113366](第10章_索引优化与查询优化.assets\image-20220618113113366.png)

从上图可以看到插入1亿条数据有序`UUID`是最快的，而且在实际业务使用中有序`UUID`在==业务端就可以生成==。还可以进一步减少`SQL`的交互次数。

另外，虽然有序`UUID`相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。

> 在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现。
>
> 另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考虑架构师的水平了。

**如果不是`MySQL 8.0`怎么办**？

手动赋值字段做主键！

比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。

可以在总部`MySQL`数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。

门店在添加会员的时候，先到总部`MySQL`数据库中获取这个最大值，在这个基础上加1，然后用这个值作为新会员的`id`，同时，更新总部`MySQL`数据库管理信息表中的当前会员编号的最大值。

这样一来。各个门店添加会员的时候，都对同一个总部`MySQL`数据库中的数据表字段进行操作，就保证了各门店会员`id`全局唯一。
