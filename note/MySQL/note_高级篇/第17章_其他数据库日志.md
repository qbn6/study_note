# 第17章_其他数据库日志

**Author**: `GaoFy`

**Reference**: `shk`

**Date**: `2022-06-23`

---

在数据库事务章节，讲过两种日志：重做日志、回滚日志

对于线上数据库应用系统，突然遭遇==数据库宕机==怎么办？在这种情况下，==定位宕机的原因==就非常关键。可以查看数据库的==错误日志==。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：从日志中发现某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。

除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。

**千万不要小看日志**，很多看似奇怪的问题，答案往往就藏在日志里。很多情况，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升数据库应用开发能力至关重要。

`MySQL 8.0`官网日志地址：http://dev.mysql.com/doc/refman/8.0/en/server-logs.html

## 1.MySQL支持的日志

---

### 1.1 日志类型

`MySQL`有不同类型的日志文件，用来存储不同类型的日志，分为==二进制日志==、==错误日志==、==通用查询日志==和==慢查询日志==，这也是常用的4种。`MySQL 8.0`又新增两种支持的日志：==中继日志==和==数据定义语句日志==。使用这些日志文件，可以查看`MySQL`内部发生的事情。

**这6类日志分别为**：

- **慢查询日志**：记录所有执行时间超过`long_query_time`的所有查询，方便我们对查询进行优化。
- **通用查询日志**：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
- **错误日志**：记录`MySQL`服务的启动、运行或停止`MySQL`服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。
- **二进制日志**：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
- **中继日志**：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
- **数据定义语句日志**：记录数据定义语句执行的元数据操作。

除二进制日志外，其他日志都是==文本文件==。默认情况下，所有日志创建于==MySQL数据目录==中。

### 1.2 日志的弊端

- 日志功能会==降低MySQL数据库的性能==。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。
- 日志会==占用大量的磁盘空间==。对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。

## 2.慢查询日志（slow query log）

---

前面章节《第09章_性能分析工具的使用》已经详细讲述。

## 3.通用查询日志（general query log）

---

通用查询日志用来==记录用户的所有操作==，包括启动和关闭MySQL服务、所有用户的连接开始和截止时间、发给MySQL数据库服务器的所有SQL指令等。当数据发生异常时，**查看通用查询日志，还原操作时的具体场景**，可以帮助我们准确定位问题。

### 3.1 问题场景

在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现==重复支付==的问题。但是当去数据库中查询数据时，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。

对系统进行仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。

查看之后，发现：1月1日下午2点，用户使用微信支付完之后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点30，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。

由于网络的原因导致了重复支付，至于解决问题的方案就很多了，这里省略。

可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。

### 3.2 查看当然状态

```mysql
mysql> show variables like '%general%';
+------------------+-----------------------------------+
| Variable_name    | Value                             |
+------------------+-----------------------------------+
| general_log      | OFF                               |
| general_log_file | /var/lib/mysql/MySQL8Learning.log |
+------------------+-----------------------------------+
2 rows in set (0.01 sec)
```

说明1：系统变量`general_log`的值是`OFF`，即通用查询日志处于关闭状态。在MySQL中，这个参数的==默认值是关闭的==。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。可以通过手动修改变量的值，在==需要的时候开启日志==。

说明2：通用查询日志文件的名称是==主机名.log==。存储路径是`/var/lib/mysql/`，默认也是数据路径。

### 3.3 启动日志

**方式1：永久性方式**

修改`my.cnf`或`my.ini`配置文件来设置。在`[mysqld]`组下加入`log`选项，并重启MySQL服务。格式如下：

```properties
[mysqld]
general_log=ON
general_log_file=[path[filename]] # 日志文件所在目录路径，filename为日志文件名
```

如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的`hostname.log`文件中，`hostname`表示主机名。

**方式2：临时性方式**

```mysql
set global general_log=on; # 开启通用查询日志
```

```mysql
set global general_log_file='path/filename'; # 设置日志文件保存位置
```

对应的，关闭操作SQL命令如下：

```mysql
set global general_log=off;
```

查看设置后情况：

```mysql
show variables like '%general%';
```

### 3.4 查看日志

通用查询日志是以==文本文件==的形式存储在文件系统中的，可以使用==文本编辑器==直接打开日志文件，每台MySQL服务器的通用查询日志内容是不同的。

- 在`Windows`操作系统中，使用文本文件查看器；
- 在`Linux`系统中，可以使用`vi`工具或`gedit`工具查看；
- 在`Mac OSX`系统中，可以使用文本文件查看器或`vi`等工具查看。

从`show variables like 'general_log%';`结果中可以看到通用查询日志的位置。

通过通用查询日志，可以了解用户对MySQL进行的操作。比如，MySQL启动信息和用户root连接服务器和执行查询表的记录。

```log
/usr/sbin/mysqld, Version: 8.0.25 (MySQL Community Server - GPL). started with:
Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock
Time                 Id Command    Argument
2022-06-23T09:15:18.878729Z         8 Query     show variables like '%general%'
2022-06-23T09:16:06.912561Z         8 Query     SELECT DATABASE()
2022-06-23T09:16:06.913112Z         8 Init DB   atguigudb3
2022-06-23T09:16:06.914074Z         8 Query     show databases
2022-06-23T09:16:06.916740Z         8 Query     show tables
2022-06-23T09:16:06.920024Z         8 Field List        account
2022-06-23T09:16:06.941512Z         8 Field List        class_comment
2022-06-23T09:16:06.942585Z         8 Field List        mylock
2022-06-23T09:16:06.956525Z         8 Field List        student
2022-06-23T09:16:06.957543Z         8 Field List        teacher
2022-06-23T09:16:06.958366Z         8 Field List        test1
2022-06-23T09:16:06.959061Z         8 Field List        test2
2022-06-23T09:16:06.961037Z         8 Field List        test_load
2022-06-23T09:16:06.962885Z         8 Field List        user
2022-06-23T09:16:11.362812Z         8 Query     show tables
2022-06-23T09:16:17.052084Z         8 Query     select * from account
2022-06-23T09:16:31.965381Z         8 Query     delete from student where id = 20
```

在通用查询日志里面，可以清楚地看到，什么时候开启了新的客户端登录数据库，登录之后做了什么SQL操作，针对的是哪个数据表等信息。

### 3.5 停止日志

**方式1：永久性方式**

修改`my.cnf`或`my.ini`文件，把`[mysqld]`组下的`general_log`值设置为`OFF`或把`general_log`一项注释掉。修改保存后，再==重启MySQL服务==，即可生效。

举例1：

```properties
[mysqld]
general_log=OFF
```

举例2：

```properties
[mysqld]
# general_log=ON
```

**方式2：临时性方式**

使用SET语句停止MySQL通用查询日志功能：

```mysql
set global general_log=off;
```

查询通用日志功能：

```mysql
show variables like 'general_log%';
```

### 3.6 删除、刷新日志

如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。

**手动删除文件**

```mysql
show variables like 'general_log%';
```

可以看到，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志`主机名.log`。

使用如下命令重新生成查询日志文件。具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。

```shell
mysqladmin uroot -p flush-logs
```

如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或改名，然后执行上面的`mysqladmin`命令。正确流程如下：

```shell
cd mysql-data-directory # 输入自己的通用日志文件所在目录
mv mysql.general.log mysql.general.log.old # 指名旧的文件名 以及 新的文件名
mysqladmin -uroot -p flush-logs
```

## 4.错误日志（error log）

---

错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括==错误==、==警告==和==提示==等。

通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务==出现异常==，错误日志是发现问题、解决故障的==首选==。

### 4.1 启动日志

在MySQL数据库中，错误日志功能是==默认开启==的。而且，错误日志==无法被禁止==。

默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为`mysqld.log`（Linux系统）或`hostname.err`（mac系统）。如果需要指定文件名，则需要在`my.cnf`或`my.ini`中做如下配置：

```properties
[mysqld]
log-error=[path[filename]] # path为日子文件所在的目录路径，filename为日志文件名
```

修改配置项后，需要重启MySQL服务以生效。

### 4.2 查看日志

MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。

查询错误日志的存储路径：

```mysql
mysql> show variables like 'log_error%';
+----------------------------+----------------------------------------+
| Variable_name              | Value                                  |
+----------------------------+----------------------------------------+
| log_error                  | /var/log/mysqld.log                    |
| log_error_services         | log_filter_internal; log_sink_internal |
| log_error_suppression_list |                                        |
| log_error_verbosity        | 2                                      |
+----------------------------+----------------------------------------+
4 rows in set (0.00 sec)
```

执行结果中可以看到错误日志文件是`mysqld.log`，位于`/var/log/mysqld.log`。

### 4.3 删除、刷新日志

对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的==磁盘空间==。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以==直接删除==。

- 第1步（方式1）：删除操作

```shell
rm -f /var/log/mysqld.log
```

在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。

- 第1步（方式2）：重命名文件

```shell
mv /var/log/mysqld.log /var/log/mysqld.log.old
```

- 第2步：重建日志

```shell
mysqladmin -u root -p flush-logs
```

可能会报错：

```shell
[root@MySQL8Learning log]# mysqladmin -u root -p flush-logs
Enter password: 
mysqladmin: refresh failed; error: 'Could not open file '/var/log/mysqld.log' for error logging.'
```

官网提示：

> **Node**
>
> For the server to recreate a given log file after you have renamed the file externally. the file location must be writable by the server. This may not always be the case. For example, on Linux, the server might write the error log as `/var/log/mysqld.log`, where` /var/log` is owned by `root` and not writable by <span style="color:skyblue">mysqld</span>. In this case, log-flushing operations fail to create a new log file.
>
> To handle this situation, you must manually create the new log file with the proper ownership after renaming the original log file. For example, execute these commands as `root`:
>
> ```shell
> mv /var/log/mysqld.log /var/log/mysqld.log.old
> install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log
> ```

补充操作：

```shell
install -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log
```

`flush-logs`指令操作：

- `MySQL 5.5.7`以前的版本，`flush-logs`将错误日志文件重命名为`filename.err_old`，并创建新的日志文件。
- 从`MySQL 5.5.7`开始，`flush-logs`只是重新打开日志文件，并不做日志备份和创建的操作。
- 如果日志文件不存在，MySQL启动或执行`flush-logs`时会自动创建新的日志文件。重新创建错误日志，大小为0字节。

### 4.4 MySQL 8.0新特性

`MySQL 8.0`里对错误日志的改进。`MySQL 8.0`的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。

下面这些是来自社区的意见：

- 默认情况下内容过于冗长
- 遗漏了忧郁的信息
- 难以过滤某些信息
- 没有标识错误信息的子系统源
- 没有错误代码，解析信息需要识别错误
- 引导信息可能会丢失
- 固定格式

针对这些意见，MySQL做了如下改变：

- 采用组件架构，通过不同的组件执行日志的写入和过滤功能
- 写入错误日志的全部信息都具有唯一的错误代码从`10000`开始
- 增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息
- 增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等
- 两种过滤方式，`internal`和`Dragnet`
- 三种写入形式，`经典`、`JSON`和`syseventlog`

> 小结：
>
> 通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间，原因，然后根据这些信息来解决异常。

## 5.二进制日志（bin log）

---

`binlog`可以说是MySQL中比较==重要==的日志了，在日常开发及运维过程中，经常会遇到。

`binlog`即`binary log`，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的`DDL`和`DML`等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句`select, show`等）。

它以==事件形式==记录并保存在==二进制文件==中。通过这些信息，可以再现数据更新操作的全过程。

> 如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通过查询日志。

`binlog`主要应用场景：

- 一是用于==数据恢复==，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。
- 二是用于==数据复制==，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到`master-slave`数据一致的目的。

可以说MySQL数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

![image-20220623190019391](第17章_其他数据库日志.assets\image-20220623190019391.png)

### 5.1 查看默认情况

查看记录二进制日志是否开启：在`MySQL 8.0`中默认情况下，二进制文件是开启的。

```mysql
mysql> show variables like '%log_bin%';
+---------------------------------+-----------------------------+
| Variable_name                   | Value                       |
+---------------------------------+-----------------------------+
| log_bin                         | ON                          |
| log_bin_basename                | /var/lib/mysql/binlog       |
| log_bin_index                   | /var/lib/mysql/binlog.index |
| log_bin_trust_function_creators | OFF                         |
| log_bin_use_v1_row_events       | OFF                         |
| sql_log_bin                     | ON                          |
+---------------------------------+-----------------------------+
6 rows in set (0.00 sec)
```

`log_bin_basename`：是`binlog`日志的基本文件名，后面会追加标识来表示每一个文件

`log_bin_index`：是`binlog`文件的索引文件，这个文件管理了所有的`binlog`文件的目录

`log_bin_trust_function_creators`：限制存储过程，前面已经说过，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用。

`log_bin_use_v1_row_events`：此只读系统变量已弃用。`ON`表示使用版本1二进制日志行，`OFF`表示使用版本2二进制日志行（`MySQL 5.6`的默认值是2）。

### 5.2 日志参数设置

**方式1：永久性方式**

修改`MySQL`的`my.cnf`或`my.ini`文件可以设置二进制日志的相关参数：

```properties
[mysqld]
# 启用二进制日志
log-bin=atguigu-bin
binlog_expire_logs_seconds=600
max_binlog_size=100M
```

> 提示：
>
> 1. `log-bin=mysql-bin`：打开日志（主机需要打开），这个`mysql-bin`也可以自定义，这里也可以加上路径，如：`/home/www/mysql_bin_log/mysql-bin`。
> 2. `binlog_expire_logs_secons`：此参数控制二进制日志文件保留的时长，单位是==秒==，默认2592000 30天 -- 14400 4小时；86400 1天；259200 3天；
> 3. `max_binlog_size`：控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的==最大和默认值是1GB==，该设置并==不能严格控制binlog的大小==，尤其是`binlog`比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录劲当前日志，直到事务结束。一般情况下可采取默认值。

重新启动MySQL服务，查询二进制日志的信息，执行结果：

```mysql
mysql> show variables like '%log_bin%';
+---------------------------------+----------------------------------+
| Variable_name                   | Value                            |
+---------------------------------+----------------------------------+
| log_bin                         | ON                               |
| log_bin_basename                | /var/lib/mysql/atguigu-bin       |
| log_bin_index                   | /var/lib/mysql/atguigu-bin.index |
| log_bin_trust_function_creators | OFF                              |
| log_bin_use_v1_row_events       | OFF                              |
| sql_log_bin                     | ON                               |
+---------------------------------+----------------------------------+
6 rows in set (0.01 sec)
```

**设置带文件夹的`bin-log`日志存放目录**

如果想改变日志文件的目录和名称，可以对`my.cnf`或`my.ini`中的`log_bin`参数修改如下：

```properties
[mysqld]
log-bin="/var/lib/mysql/binlog/atguigu-bin"
```

注意：新建的文件夹需要使用`mysql`用户，使用下面的命令即可。

```shell
chown -R -v mysql:mysql binlog
```

重启MySQL服务之后，新的二进制日志文件将出现在`/var/lib/mysql/binlog/`文件夹下面：

```mysql
mysql> show variables like '%log_bin%';
+---------------------------------+-----------------------------------------+
| Variable_name                   | Value                                   |
+---------------------------------+-----------------------------------------+
| log_bin                         | ON                                      |
| log_bin_basename                | /var/lib/mysql/binlog/atguigu-bin       |
| log_bin_index                   | /var/lib/mysql/binlog/atguigu-bin.index |
| log_bin_trust_function_creators | OFF                                     |
| log_bin_use_v1_row_events       | OFF                                     |
| sql_log_bin                     | ON                                      |
+---------------------------------+-----------------------------------------+
6 rows in set (0.01 sec)
```

```shell
[root@MySQL8Learning binlog]# ll
总用量 8
-rw-r-----. 1 mysql mysql 156 6月  23 19:40 atguigu-bin.000001
-rw-r-----. 1 mysql mysql  41 6月  23 19:40 atguigu-bin.index
[root@MySQL8Learning binlog]# pwd
/var/lib/mysql/binlog
```

> 提示：
>
> ==数据库文件最好不要与日志文件放在同一个磁盘上==！这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。

**方式2：临时性方式**

如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在`MySQL8`中只有==会话级别==的设置，没有了`global`级别的设置。

```mysql
# global 级别
mysql> set global sql_log_bin=0;
ERROR 1228 (HY000): Variable 'sql_log_bin' is a SESSION variable and can't be used with SET GLOBAL

# session 级别
mysql> set sql_log_bin=0;
Query OK, 0 rows affected (0.01 sec)
```

### 5.3 查看日志

当MySQL创建二进制日志文件时，先创建一个以"filename"为名称，以".index"为后缀的文件，再创建一个以"filename"为名称、以".000001"为后缀的文件。

MySQL服务==重新启动一次==，以".000001"为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了`max_binlog_size`的上限（默认是1GB），就会创建一个新的日志文件。

查看当前的二进制日志文件列表及大小。指令如下：

```mysql
mysql> show binary logs;
+--------------------+-----------+-----------+
| Log_name           | File_size | Encrypted |
+--------------------+-----------+-----------+
| atguigu-bin.000001 |       156 | No        |
+--------------------+-----------+-----------+
1 row in set (0.00 sec)
```

所有对数据库的修改都会记录在`binlog`中。但`binlog`是二进制文件，无法直接查看，想要更直观的观测它就要借助`mysqlbinlog`命令工具了。指令如下：在查看执行，先执行一条SQL语句，如下

```mysql
update student set `name` = 'tom1' where id = 1;
```

开始查看`binlog`

```shell
[root@MySQL8Learning binlog]# mysqlbinlog "/var/lib/mysql/binlog/atguigu-bin.000001"
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#220623 19:40:08 server id 1  end_log_pos 125 CRC32 0xcfee1ac3 	Start: binlog v 4, server v 8.0.25 created 220623 19:40:08 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
GFG0Yg8BAAAAeQAAAH0AAAABAAQAOC4wLjI1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAYUbRiEwANAAgAAAAABAAEAAAAYQAEGggAAAAICAgCAAAACgoKKioAEjQA
CigBwxruzw==
'/*!*/;
# at 125
#220623 19:40:08 server id 1  end_log_pos 156 CRC32 0x22438d2d 	Previous-GTIDs
# [empty]
# at 156
#220623 19:51:26 server id 1  end_log_pos 235 CRC32 0x48f7bbeb 	Anonymous_GTID	last_committed=0	sequence_number=1	rbr_only=yes	original_committed_timestamp=1655985086393545	immediate_commit_timestamp=1655985086393545	transaction_length=314
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
# immediate_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985086393545*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 235
#220623 19:51:26 server id 1  end_log_pos 316 CRC32 0xf890450e 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985086/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8mb4 *//*!*/;
SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 316
#220623 19:51:26 server id 1  end_log_pos 386 CRC32 0x4f53e914 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 386
#220623 19:51:26 server id 1  end_log_pos 439 CRC32 0xe20c0c52 	Write_rows: table id 94 flags: STMT_END_F

BINLOG '
vlO0YhMBAAAARgAAAIIBAAAAAF4AAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwRQACgA
BgEBAAID/P8AFOlTTw==
vlO0Yh4BAAAANQAAALcBAAAAAF4AAAAAAAEAAgAD/wASAAAABWplcnJ5BuWbm+ePrVIMDOI=
'/*!*/;
# at 439
#220623 19:51:26 server id 1  end_log_pos 470 CRC32 0x8c11ec92 	Xid = 20
COMMIT/*!*/;
# at 470
#220623 19:51:46 server id 1  end_log_pos 549 CRC32 0x634d6d40 	Anonymous_GTID	last_committed=1	sequence_number=2	rbr_only=yes	original_committed_timestamp=1655985106611862	immediate_commit_timestamp=1655985106611862	transaction_length=342
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
# immediate_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985106611862*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 549
#220623 19:51:46 server id 1  end_log_pos 639 CRC32 0xa3d388e8 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985106/*!*/;
BEGIN
/*!*/;
# at 639
#220623 19:51:46 server id 1  end_log_pos 709 CRC32 0xa221cb65 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 709
#220623 19:51:46 server id 1  end_log_pos 781 CRC32 0x73d4e914 	Update_rows: table id 94 flags: STMT_END_F

BINLOG '
0lO0YhMBAAAARgAAAMUCAAAAAF4AAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwRQACgA
BgEBAAID/P8AZcshog==
0lO0Yh8BAAAASAAAAA0DAAAAAF4AAAAAAAEAAgAD//8AAQAAAAblvKDkuIkG5LiA54+tAAEAAAAE
dG9tMQbkuIDnj60U6dRz
'/*!*/;
# at 781
#220623 19:51:46 server id 1  end_log_pos 812 CRC32 0x26459f0b 	Xid = 21
COMMIT/*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为`binlog`关键字后面的内容是经过编码后的==二进制日志==。

这里一个`update`语句包含如下事件

- `Query`事件负责开始一个事务（BEGIN）
- `Table_map`事件负责映射需要的表
- `Update_rows`事件负责写入数据
- `Xid`事件负责结束事务

下面命令将行事件以==伪SQL的形式==表现出来

```shell
[root@MySQL8Learning binlog]# mysqlbinlog -v "/var/lib/mysql/binlog/atguigu-bin.000001"
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#220623 19:40:08 server id 1  end_log_pos 125 CRC32 0xcfee1ac3 	Start: binlog v 4, server v 8.0.25 created 220623 19:40:08 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
GFG0Yg8BAAAAeQAAAH0AAAABAAQAOC4wLjI1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAYUbRiEwANAAgAAAAABAAEAAAAYQAEGggAAAAICAgCAAAACgoKKioAEjQA
CigBwxruzw==
'/*!*/;
# at 125
#220623 19:40:08 server id 1  end_log_pos 156 CRC32 0x22438d2d 	Previous-GTIDs
# [empty]
# at 156
#220623 19:51:26 server id 1  end_log_pos 235 CRC32 0x48f7bbeb 	Anonymous_GTID	last_committed=0	sequence_number=1	rbr_only=yes	original_committed_timestamp=1655985086393545	immediate_commit_timestamp=1655985086393545	transaction_length=314
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
# immediate_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985086393545*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 235
#220623 19:51:26 server id 1  end_log_pos 316 CRC32 0xf890450e 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985086/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8mb4 *//*!*/;
SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 316
#220623 19:51:26 server id 1  end_log_pos 386 CRC32 0x4f53e914 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 386
#220623 19:51:26 server id 1  end_log_pos 439 CRC32 0xe20c0c52 	Write_rows: table id 94 flags: STMT_END_F

BINLOG '
vlO0YhMBAAAARgAAAIIBAAAAAF4AAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwRQACgA
BgEBAAID/P8AFOlTTw==
vlO0Yh4BAAAANQAAALcBAAAAAF4AAAAAAAEAAgAD/wASAAAABWplcnJ5BuWbm+ePrVIMDOI=
'/*!*/;
### INSERT INTO `atguigudb3`.`student`
### SET
###   @1=18
###   @2='jerry'
###   @3='四班'
# at 439
#220623 19:51:26 server id 1  end_log_pos 470 CRC32 0x8c11ec92 	Xid = 20
COMMIT/*!*/;
# at 470
#220623 19:51:46 server id 1  end_log_pos 549 CRC32 0x634d6d40 	Anonymous_GTID	last_committed=1	sequence_number=2	rbr_only=yes	original_committed_timestamp=1655985106611862	immediate_commit_timestamp=1655985106611862	transaction_length=342
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
# immediate_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985106611862*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 549
#220623 19:51:46 server id 1  end_log_pos 639 CRC32 0xa3d388e8 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985106/*!*/;
BEGIN
/*!*/;
# at 639
#220623 19:51:46 server id 1  end_log_pos 709 CRC32 0xa221cb65 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 709
#220623 19:51:46 server id 1  end_log_pos 781 CRC32 0x73d4e914 	Update_rows: table id 94 flags: STMT_END_F

BINLOG '
0lO0YhMBAAAARgAAAMUCAAAAAF4AAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwRQACgA
BgEBAAID/P8AZcshog==
0lO0Yh8BAAAASAAAAA0DAAAAAF4AAAAAAAEAAgAD//8AAQAAAAblvKDkuIkG5LiA54+tAAEAAAAE
dG9tMQbkuIDnj60U6dRz
'/*!*/;
### UPDATE `atguigudb3`.`student`
### WHERE
###   @1=1
###   @2='张三'
###   @3='一班'
### SET
###   @1=1
###   @2='tom1'
###   @3='一班'
# at 781
#220623 19:51:46 server id 1  end_log_pos 812 CRC32 0x26459f0b 	Xid = 21
COMMIT/*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

前面的命令同时显示`binlog`格式的语句，使用如下命令不显示

```shell
[root@MySQL8Learning binlog]# mysqlbinlog -v --base64-output=DECODE-ROWS "/var/lib/mysql/binlog/atguigu-bin.000001"
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#220623 19:40:08 server id 1  end_log_pos 125 CRC32 0xcfee1ac3 	Start: binlog v 4, server v 8.0.25 created 220623 19:40:08 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
# at 125
#220623 19:40:08 server id 1  end_log_pos 156 CRC32 0x22438d2d 	Previous-GTIDs
# [empty]
# at 156
#220623 19:51:26 server id 1  end_log_pos 235 CRC32 0x48f7bbeb 	Anonymous_GTID	last_committed=0	sequence_number=1	rbr_only=yes	original_committed_timestamp=1655985086393545	immediate_commit_timestamp=1655985086393545	transaction_length=314
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
# immediate_commit_timestamp=1655985086393545 (2022-06-23 19:51:26.393545 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985086393545*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 235
#220623 19:51:26 server id 1  end_log_pos 316 CRC32 0xf890450e 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985086/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8mb4 *//*!*/;
SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 316
#220623 19:51:26 server id 1  end_log_pos 386 CRC32 0x4f53e914 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 386
#220623 19:51:26 server id 1  end_log_pos 439 CRC32 0xe20c0c52 	Write_rows: table id 94 flags: STMT_END_F
### INSERT INTO `atguigudb3`.`student`
### SET
###   @1=18
###   @2='jerry'
###   @3='四班'
# at 439
#220623 19:51:26 server id 1  end_log_pos 470 CRC32 0x8c11ec92 	Xid = 20
COMMIT/*!*/;
# at 470
#220623 19:51:46 server id 1  end_log_pos 549 CRC32 0x634d6d40 	Anonymous_GTID	last_committed=1	sequence_number=2	rbr_only=yes	original_committed_timestamp=1655985106611862	immediate_commit_timestamp=1655985106611862	transaction_length=342
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
# immediate_commit_timestamp=1655985106611862 (2022-06-23 19:51:46.611862 CST)
/*!80001 SET @@session.original_commit_timestamp=1655985106611862*//*!*/;
/*!80014 SET @@session.original_server_version=80025*//*!*/;
/*!80014 SET @@session.immediate_server_version=80025*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 549
#220623 19:51:46 server id 1  end_log_pos 639 CRC32 0xa3d388e8 	Query	thread_id=8	exec_time=0	error_code=0
SET TIMESTAMP=1655985106/*!*/;
BEGIN
/*!*/;
# at 639
#220623 19:51:46 server id 1  end_log_pos 709 CRC32 0xa221cb65 	Table_map: `atguigudb3`.`student` mapped to number 94
# at 709
#220623 19:51:46 server id 1  end_log_pos 781 CRC32 0x73d4e914 	Update_rows: table id 94 flags: STMT_END_F
### UPDATE `atguigudb3`.`student`
### WHERE
###   @1=1
###   @2='张三'
###   @3='一班'
### SET
###   @1=1
###   @2='tom1'
###   @3='一班'
# at 781
#220623 19:51:46 server id 1  end_log_pos 812 CRC32 0x26459f0b 	Xid = 21
COMMIT/*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

关于`mysqlbinlog`工具的使用技巧还有很多，例如只解析对某个库的操作或某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。

```shell
# 可查看参数帮助
mysqlbinlog --no-defaults --help

# 查看最后100行
mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000001 |tail -100

# 根据position查找
mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000001 |grep -A 20 '4939002'
```

上面这种办法读取出`binlog`日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：

```mysql
mysql> show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];
```

- `IN 'log_name'`：指定要查询的`binlog`文件名（不指定就是第一个`binlog`文件）
- `FROM pos`：指定从哪个pos起始点开始查找（不指定就是从整个文件首个pos点开始算）
- `LIMIT [offset]`：偏移量（不指定就是0）
- `row_count`：查询总条数（不指定就是所有行）

```mysql
mysql> show binlog events in 'atguigu-bin.000001';;
+--------------------+-----+----------------+-----------+-------------+--------------------------------------+
| Log_name           | Pos | Event_type     | Server_id | End_log_pos | Info                                 |
+--------------------+-----+----------------+-----------+-------------+--------------------------------------+
| atguigu-bin.000001 |   4 | Format_desc    |         1 |         125 | Server ver: 8.0.25, Binlog ver: 4    |
| atguigu-bin.000001 | 125 | Previous_gtids |         1 |         156 |                                      |
| atguigu-bin.000001 | 156 | Anonymous_Gtid |         1 |         235 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 235 | Query          |         1 |         316 | BEGIN                                |
| atguigu-bin.000001 | 316 | Table_map      |         1 |         386 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 386 | Write_rows     |         1 |         439 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 439 | Xid            |         1 |         470 | COMMIT /* xid=20 */                  |
| atguigu-bin.000001 | 470 | Anonymous_Gtid |         1 |         549 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 549 | Query          |         1 |         639 | BEGIN                                |
| atguigu-bin.000001 | 639 | Table_map      |         1 |         709 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 709 | Update_rows    |         1 |         781 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 781 | Xid            |         1 |         812 | COMMIT /* xid=21 */                  |
+--------------------+-----+----------------+-----------+-------------+--------------------------------------+
12 rows in set (0.00 sec)
```

上面这条语句可以将指定的`binlog`日志文件，分成有效事件行的方式返回，并可使用`limit`指定`pos`点的起始偏移，查询条数。其他举例：

```mysql
# a.查询第一个最早的binlog日志；
show binlog events \G

# b.指定查询atguigu-bin.000001这个文件
show binlog events in 'atguigu-bin.000001' \G

# c.指定查询atguigu-bin.000001这个文件，从pos点：391 开始查找
show binlog events in 'atguigu-bin.000001' from 391 \G

# d.指定查询atguigu-bin.000001这个文件，从pos点：391 开始查找，查询5条（即5条语句）
show binlog events in 'atguigu-bin.000001' from 391 limit 5 \G
```

上面这么多都是基于`binlog`的默认格式，`binlog`格式查看

```mysql
mysql> show variables like 'binlog_format';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.00 sec)
```

除此之外，`binlog`还有2种格式，分别是**Statement**和**Mixed**

- **Statement**

每一条会修改数据的SQL都会记录在`binlog`中。

优点：不需要记录每一行的变化，减少了`binlog`日志量，节约了IO，提高性能。

- **Row**

`5.1.5`版本的MySQL才开始支持`row level`的复制，它不记录SQL语句上下文相关信息，仅保存哪条记录被修改。

优点：`row level`的日志内容会非常清楚的记录每一行数据修改的细节，而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。

- **Mixed**

从`5.1.8`版本开始，MySQL提供了`Mixed`格式，实际上就是`Statement`与`Row`的结合。

### 5.4 使用日志恢复数据

如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用`MySQLbinlog`工具从指定的时间点开始（例如，最后一次备份）直到现在，或另一个指定的时间点的日志中恢复数据。

`mysqlbinlog`恢复数据的语法如下：

```shell
mysqlbinlog [option] filename|mysql -uuser -ppass;
```

这个命令可以这样理解：使用`mysqlbinlog`命令来读取`filename`中的内容，然后使用`mysql`命令将这些内容恢复到数据库中。

- `filename`：是日志文件名
- `option`：可选项，比较重要的两对`option`参数是`--start-date`、`--stop-date`和`--start-position`、`--stop-position`。
  - `--start-date`和`--stop-date`：可以指定恢复数据库的起始时间点和结束时间点。
  - `--start-position`和`--stop-position`：可以指定恢复数据的开始位置和结束位置。

> 注意：使用`mysqlbinlog`命令进行恢复操作时，必须是编号小的先恢复，例如`atguigu-bin.000001`必须在`atguigu-bin.000002`之前恢复。

案例：

现在对`student`表有以下操作

```mysql
# 查询数据
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
+----+-------+--------+
2 rows in set (0.00 sec)

# 插入三条数据
mysql> insert into student values(20,'aaa','No.1');
Query OK, 1 row affected (0.00 sec)

mysql> insert into student values(21,'aaa','No.1');
Query OK, 1 row affected (0.00 sec)

mysql> insert into student values(22,'aaa','No.1');
Query OK, 1 row affected (0.00 sec)

# 查询数据
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 20 | aaa   | No.1   |
| 21 | aaa   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
5 rows in set (0.01 sec)

# 删除数据
mysql> delete from student where id=20;
Query OK, 1 row affected (0.00 sec)

# 查询数据
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 21 | aaa   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
4 rows in set (0.00 sec)

# 更新数据
mysql> update student set name='bbb' where id = 21;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

# 查询数据
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 21 | bbb   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
4 rows in set (0.00 sec)

# 批量删除数据
mysql> delete from student where id > 20;
Query OK, 2 rows affected (0.01 sec)

# 查询数据
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
+----+-------+--------+
2 rows in set (0.00 sec)
```

上面是对`student`表的增删查改操作。现在不小心删除了所有新增的数据，现在目标就是恢复后面的新增，更新和删除的数据。当前表中数据如下：

```mysql
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
+----+-------+--------+
2 rows in set (0.00 sec)
```

接下来查看`binlog`，如下所示：

```mysql
mysql> show binary logs;
+--------------------+-----------+-----------+
| Log_name           | File_size | Encrypted |
+--------------------+-----------+-----------+
| atguigu-bin.000001 |      2710 | No        |
+--------------------+-----------+-----------+
1 row in set (0.00 sec)
```

上面所有操作都保存在`atguigu-bin.000001`日志中，如果工作中可以先备份下这个`atguigu-bin.000001`日志文件，接着执行`flush logs`刷新日志，重新创建一个`binlog`日志2

```mysql
mysql> flush logs;
Query OK, 0 rows affected (0.03 sec)

mysql> show binary logs;
+--------------------+-----------+-----------+
| Log_name           | File_size | Encrypted |
+--------------------+-----------+-----------+
| atguigu-bin.000001 |      2759 | No        |
| atguigu-bin.000002 |       156 | No        |
+--------------------+-----------+-----------+
2 rows in set (0.00 sec)
```

重新创建一个日志2的目的：接下来所有操作的数据都会写入到日志2中，日志1中不会再写入任何数据（方便根据日志2的内容恢复数据，因为日志1的数据就是备份之后到删库之前的所有操作日志，重建日志2不会有过多的数据影响恢复）

登录MySQL查看日志2：`show binlog events in 'atguigu-bin.000001';`结果如下：

```mysql
mysql> show binlog events in 'atguigu-bin.000001';
+--------------------+------+----------------+-----------+-------------+--------------------------------------+
| Log_name           | Pos  | Event_type     | Server_id | End_log_pos | Info                                 |
+--------------------+------+----------------+-----------+-------------+--------------------------------------+
| atguigu-bin.000001 |    4 | Format_desc    |         1 |         125 | Server ver: 8.0.25, Binlog ver: 4    |
| atguigu-bin.000001 |  125 | Previous_gtids |         1 |         156 |                                      |
| atguigu-bin.000001 |  156 | Anonymous_Gtid |         1 |         235 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 |  235 | Query          |         1 |         316 | BEGIN                                |
| atguigu-bin.000001 |  316 | Table_map      |         1 |         386 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 |  386 | Write_rows     |         1 |         439 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 |  439 | Xid            |         1 |         470 | COMMIT /* xid=20 */                  |
| atguigu-bin.000001 |  470 | Anonymous_Gtid |         1 |         549 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 |  549 | Query          |         1 |         639 | BEGIN                                |
| atguigu-bin.000001 |  639 | Table_map      |         1 |         709 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 |  709 | Update_rows    |         1 |         781 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 |  781 | Xid            |         1 |         812 | COMMIT /* xid=21 */                  |
| atguigu-bin.000001 |  812 | Anonymous_Gtid |         1 |         891 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 |  891 | Query          |         1 |         972 | BEGIN                                |
| atguigu-bin.000001 |  972 | Table_map      |         1 |        1042 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 1042 | Write_rows     |         1 |        1091 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 1091 | Xid            |         1 |        1122 | COMMIT /* xid=30 */                  |
| atguigu-bin.000001 | 1122 | Anonymous_Gtid |         1 |        1201 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 1201 | Query          |         1 |        1282 | BEGIN                                |
| atguigu-bin.000001 | 1282 | Table_map      |         1 |        1352 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 1352 | Write_rows     |         1 |        1401 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 1401 | Xid            |         1 |        1432 | COMMIT /* xid=31 */                  |
| atguigu-bin.000001 | 1432 | Anonymous_Gtid |         1 |        1511 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 1511 | Query          |         1 |        1592 | BEGIN                                |
| atguigu-bin.000001 | 1592 | Table_map      |         1 |        1662 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 1662 | Write_rows     |         1 |        1711 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 1711 | Xid            |         1 |        1742 | COMMIT /* xid=32 */                  |
| atguigu-bin.000001 | 1742 | Anonymous_Gtid |         1 |        1821 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 1821 | Query          |         1 |        1902 | BEGIN                                |
| atguigu-bin.000001 | 1902 | Table_map      |         1 |        1972 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 1972 | Delete_rows    |         1 |        2021 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 2021 | Xid            |         1 |        2052 | COMMIT /* xid=34 */                  |
| atguigu-bin.000001 | 2052 | Anonymous_Gtid |         1 |        2131 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 2131 | Query          |         1 |        2221 | BEGIN                                |
| atguigu-bin.000001 | 2221 | Table_map      |         1 |        2291 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 2291 | Update_rows    |         1 |        2355 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 2355 | Xid            |         1 |        2386 | COMMIT /* xid=36 */                  |
| atguigu-bin.000001 | 2386 | Anonymous_Gtid |         1 |        2465 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| atguigu-bin.000001 | 2465 | Query          |         1 |        2546 | BEGIN                                |
| atguigu-bin.000001 | 2546 | Table_map      |         1 |        2616 | table_id: 94 (atguigudb3.student)    |
| atguigu-bin.000001 | 2616 | Delete_rows    |         1 |        2679 | table_id: 94 flags: STMT_END_F       |
| atguigu-bin.000001 | 2679 | Xid            |         1 |        2710 | COMMIT /* xid=38 */                  |
| atguigu-bin.000001 | 2710 | Rotate         |         1 |        2759 | atguigu-bin.000002;pos=4             |
+--------------------+------+----------------+-----------+-------------+--------------------------------------+
43 rows in set (0.00 sec)
```

查看日志发现，在备份数据后首先执行的是插入数据操作，在info信息中xid的值分别是30，31，32。

**步骤1：恢复插入的数据**

插入的操作在三个事务中，而且三个事务是连在一起的，所以我们可以直接恢复三个事务，开始pos是972，结束pos是1821

```shell
/usr/bin/mysqlbinlog --start-position=972 --stop-position=1821 --database=atguigudb3 /var/lib/mysql/binlog/atguigu-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3
```

结果如下：

```mysql
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 20 | aaa   | No.1   |
| 21 | aaa   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
5 rows in set (0.00 sec)
```

**步骤2：恢复删除操作**

重新操作的开始pos是1902，结束pos是2131

```shell
/usr/bin/mysqlbinlog --start-position=1902 --stop-position=2131 --database=atguigudb3 /var/lib/mysql/binlog/atguigu-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3
```

执行完结果如下：

```mysql
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 21 | aaa   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
4 rows in set (0.00 sec)
```

**步骤3：恢复修改操作**

修改操作的开始pos是2221，结束的pos是2465

```shell
/usr/bin/mysqlbinlog --start-position=2221 --stop-position=2465 --database=atguigudb3 /var/lib/mysql/binlog/atguigu-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3
```

执行完结果如下：

```mysql
mysql> select * from student;
+----+-------+--------+
| id | name  | class  |
+----+-------+--------+
|  1 | tom1  | 一班   |
| 18 | jerry | 四班   |
| 21 | bbb   | No.1   |
| 22 | aaa   | No.1   |
+----+-------+--------+
4 rows in set (0.00 sec)
```

可以看到最终结果和批量删除数据之前的结果一样，利用`binlog`实现了数据恢复。

当然也可以使用日期恢复，命令格式如下：

```shell
/usr/bin/mysqlbinlog --start-datetime="2022-01-05 15:39:22" --stop-datetime="2022-01-05 15:40:19" --database=atguigudb3 /var/lib/mysql/binlog/atguigu-bin.000001 | /usr/bin/mysql -uroot -proot -v atguigudb3
```

日期可以根据`binlog`日志详情查看，如下所示。可能出现一个事务执行时间过短，那么就是同样的时间，一秒内执行完成，此时我们找到下一个事务的开始时间即可，多计算一些时间就可以了。本次事务的开始时间是220105 15:39:22，结束时间设置为220105 15:40:19。<span style="color:red;font-weight:bold">（未操作）</span>

```mysql
# at 773
#220105 15:39:22 server id 1  end_log_pos 853 CRC32 0xebbb5e68 	Query	thread_id=12	exec_time=0	error_code=0
SET TIMESTAMP=1641368362/*!*/;
BEGIN
/*!*/;
# at 853
#220105 15:39:22 server id 1  end_log_pos 920 CRC32 0xfd67d362 	Table_map: `atguigudb14`.`student` mapped to number 81
# at 920
#220105 15:39:22 server id 1  end_log_pos 969 CRC32 0x0350cb82 	Write_rows: table id 81 flags: STMT_END_F

BINLOG '
KkvVYRMBAAAAQwAAAJgDAAAAAFEAAAAAAAEACWF0Z3VpZ3UxNAAHc3R1ZGVudAADAw8PBDwAHgAG
AQEAAgEhYtNn/Q==
KkvVYR4BAAAAMQAAAMkDAAAAAFEAAAAAAAEAAgAD/wAXAAAAA2xpNAQxYmFugstQAw==
'/*!*/;
### INSERT INTO `atguigu14`.`student`
### SET
###	   @1=23
###    @2='li4'
###    @3='1ban'
# at 969
#220105 15:39:22 server id 1  end_log_pos 1000 CRC32 0xcb1c893b 	Xid = 82
COMMIT/*!*/;
#220105 15:40:19 server id 1  end_log_pos 1387 CRC32 0x38073b2f 	Anonymous_GTID	last_committed=4	sequence_number=5	rbr_only=yes	original_committed_timestamp=1641368419039947	immediate_commit_timestamp=1641368419039947	transaction_length=343
```

`mysqlbinlog`命令对于意外操作非常有效，比如因操作不当误删了数据表。

### 5.5 删除二进制日志

MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。`PURGE MASTER LOGS`只删除指定部分的二进制日志文件，`RESET MASTER`删除所有的二进制日志文件。具体如下：

**1.`PURGE MASTER LOGS`：删除指定日志文件**

`PURGE MASTER LOGS`语法如下：

```mysql
PURGE {MASTER | BINARY} LOGS TO '指定日志文件名';
PURGE {MASTER | BINARY} LOGS BEFORE '指定日期';
```

**举例**：使用`PURGE MASTER LOGS`语句删除创建时间比`atguigu-bin.000003`早的所有日志

（1）多次重启MySQL服务，便于生成多个日志文件，然后用SHOW语句显示二进制日志文件列表

```mysql
SHOW BINARY LOGS;

# 不重启生成多个日志文件的方法
flush logs;
```

（2）执行`PURGE MASTER LOGS`语句删除创建时间比`atguigu-bin.000003`早的所有日志

```mysql
PURGE MASTER LOGS TO "atguigu-bin.000003";
```

（3）显示二进制日志文件列表

```mysql
mysql> show binary logs;
+--------------------+-----------+-----------+
| Log_name           | File_size | Encrypted |
+--------------------+-----------+-----------+
| atguigu-bin.000003 |       205 | No        |
| atguigu-bin.000004 |       205 | No        |
| atguigu-bin.000005 |       205 | No        |
| atguigu-bin.000006 |       205 | No        |
| atguigu-bin.000007 |       156 | No        |
+--------------------+-----------+-----------+
5 rows in set (0.00 sec)
```

比`atguigu-bin.000003`早的所有日志文件都已经被删除了。

**举例**：使用`PURGE MASTER LOGS`语句删除2020年10月25日之前创建的所有日志文件。具体步骤如下：<span style="color:red;font-weight:bold">（未操作）</span>

（1）显示二进制日志文件列表

```mysql
SHOW BINARY LOGS;
```

（2）执行`mysqlbinlog`命令查看二进制日志文件`atguigu-bin.000005`的内容

```shell
mysqlbinlog --no-defaults "/var/lib/mysql/binlog/atguigu-bin.000005"
```

结果可以看出20220105为日志创建的时间，即2022年1月05日。

（3）使用`PURGE MASTER LOGS`语句删除2022年1月05日前创建的所有日志文件

```mysql
PURGE MASTER LOGS BEFORE '20220105';
```

（4）显示二进制日志文件列表

```mysql
SHOW BINARY LOGS;
```

2022年01月05日之前的二进制日志文件都已经被删除。

**2.`RESET MASTER`：删除所有二进制日志文件**

使用`RESET MASTER`语句，清空所有的`binlog`日志。`MySQL`会重新创建二进制文件，新的日志文件扩展名将重新从`000001`开始编号。==慎用！==

**举例**：使用`RESET MASTER`语句删除所有日志文件。

（1）创建多个二进制日志文件

```mysql
flush logs;
```

（2）执行`RESET MASTER`语句，删除所有日志文件

```mysql
RESET MASTER;
```

执行完语句后，原来的所有二进制日志已经全部删除。

### 5.6 其他场景

二进制日志可以通过数据库的==全量备份==和二进制日志中保存的==增量信息==，完成数据库的==无损失恢复==。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。

在这种情况下，一个有效的解决办法是==配置主从数据库服务==，甚至是==一主多从==的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。

## 6.再谈二进制日志（binlog）

---

### 6.1 写入机制

`binlog`的写入时机也非常简单，事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。

可以通过`binlog_cache_size`参数控制单个线程`binlog cache`大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。`binlog`日志刷盘流程如下：

![image-20220623224255551](第17章_其他数据库日志.assets\image-20220623224255551.png)

> - 上图的`write`，是指把日志写入到文件系统的`page cache`，并没有把数据持久化到磁盘，所以速度比较快
> - 上图的`fsync`，才是将数据持久化到磁盘的操作

`write`和`fsync`的时机，可以由参数`sync_binlog`控制，默认为`0`。为0的时候，表示每次提交事务都只`write`，由系统自行判断什么时候执行`fsync`。虽然性能得到了提升，但是机器宕机，`page cache`里面的`binlog`会丢失。如下图：

![设置为0](第17章_其他数据库日志.assets\设置为0.png)

为了安全起见，可以设置为`1`，表示每次提交事务都会执行`fsync`，就如同**redo log 刷盘流程**一样。

最后还有一种折中方式，可以设置为N(N>1)，表示每次提交事务都`write`，但累计`N`个事务后才`fsync`。

![22697249-fda4f937b0dcebee](第17章_其他数据库日志.assets\22697249-fda4f937b0dcebee.png)

在出现IO瓶颈的场景下，将`sync_binlog`设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的`binlog`日志。

### 6.2 binlog与redo log对比

- `redo log`它是==物理日志==，记录内容是"在某个数据页上做了什么修改"，属于`InnoDB`存储引擎层产生的。
- 而`binlog`是==逻辑日志==，记录内容是语句的原始逻辑，类似于"给ID=2这一行的c字段加1"，属于MySQL Server层。
- 虽然它们都属于持久化的保证，但是则重点不同。
  - `redo log`让`InnoDB`存储引擎拥有了崩溃恢复能力。
  - `binlog`保证了MySQL集群架构的数据一致性。

### 6.3 两阶段提交

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的==写入时机==不一样。

![22697249-2d40c3611751a98d](第17章_其他数据库日志.assets\22697249-2d40c3611751a98d.png)

**`redo log`与`binlog`两份日志之间的逻辑不一致，会出现什么问题**？

以`update`语句为例，假设`id=2`的记录，字段`c`值是`0`，把字段c值更新成1，SQL语句为`update T set c=1 where id=2`。

假设执行过程中写完`redo log`日志后，`binlog`日志写时期发生了异常，会出现什么情况呢？

![22697249-d8026e7e7a7091aa](第17章_其他数据库日志.assets\22697249-d8026e7e7a7091aa.png)

由于`binlog`没写完就异常了，这时候`binlog`里面没有对应的修改记录。因此，之后用`binlog`日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为`redo log`日志恢复，这一行c值是1，最终数据不一致。

![22697249-43a2cfacbd1e7f63](第17章_其他数据库日志.assets\22697249-43a2cfacbd1e7f63.png)

为了解决两份日志之间的逻辑一致问题，`InnoDB`存储引擎使用**两阶段提交**方案，原理很简单，将`redo log`的写入拆成了两个步骤`prepare`和`commit`，这就是**两阶段提交**。

![22697249-4a0e5588ee64be06](第17章_其他数据库日志.assets\22697249-4a0e5588ee64be06.png)

使用**两阶段提交**后，写入`binlog`时发生异常也不会有影响，因为MySQL根据`redo log`日志恢复数据时，发现`redo log`还处于`prepare`阶段，并且没有对应`binlog`日志，就会回滚该事务。

![22697249-a54e5c622b525aed](第17章_其他数据库日志.assets\22697249-a54e5c622b525aed.png)

另一个场景，`redo log`设置`commit`阶段发生异常，那会不会回滚事务呢？

![22697249-c73989dcf49bc910](第17章_其他数据库日志.assets\22697249-c73989dcf49bc910.png)

并不会回滚事务，它会执行上图框住的逻辑，虽然`redo log`是处于`prepare`阶段，但是能通过事务`id`找到对应的`binlog`日志，所以`MySQL`认为是完整的，就会提交事务恢复数据。

## 7.中继日志（relay log）

---

### 7.1 介绍

**中继日志只在主从服务器架构的从服务器上存在**。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入==本地的日志文件==中，这个从服务器本地的日志文件就叫==中继日志==。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的==数据同步==。

搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。

文件名的格式是：==从服务器名 -relay-bin.序号==。中继日志还有一个索引文件：==从服务器名 -relay-bin.index==，用来定位当前正在使用的中继日志。

### 7.2 查看中继日志

中继日志与二进制日志的格式相同，可以用`mysqlbinlog`工具进行查看。下面是中继日志的一个片段：

![image-20220623233217733](第17章_其他数据库日志.assets\image-20220623233217733.png)

这一段的意思是，主服务器（"serverid 1"）对表`atguigu.test`进行了2步操作：

```text
定位到表 atguigu.test 编号是 91 的记录，日志位置是 832
删除编号是 91 的记录，日志位置是 872
```

### 7.3 恢复的典型错误

如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致==服务器名称==与之前==不同==。而中继日志里是==包含从服务器名==的。在这种情况下，就可能会导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。

解决的方法也很简单，把从服务器的名称改回之前的名称。