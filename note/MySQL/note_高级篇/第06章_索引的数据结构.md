# 第06章_索引的数据结构

**Author**: `GaoFy`

**Reference**: `shk`

**Date**: `2022-06-08`

---

## 1.为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可以快速定位到需要的文章。`MySQL`中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则==通过索引查找==相关数据，如果不符合则需要==全表扫描==，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image-20220607205737984](第06章_索引的数据结构.assets\image-20220607205737984.png)

如上图所示，数据库没有索引的情况下，数据==分布在硬盘不同的位置上面==，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果==数据顺序摆放==，那么也需要从`1`到`6`行按顺序读取，这样就相当于进行了6次IO操作，==依旧非常耗时==。如果不借助任何索引结构帮助我们快速定位数据的话，我们查找`Col2 = 89`这条记录，就要逐行去查找、去比较。从`Col2 = 34`开始，进行比较，发现不是，继续下一行。我们当前的表只有不到`10`行数据，但如果表很大的话，有==上千万条数据==，就意味着要做==很多很多次磁盘I/O==才能找到。现在要查找`Col2 = 89`这条记录，`CPU`必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘`I/O`（涉及到磁盘的旋转时间（速度较快）、磁头的寻道时间（速度慢、费时））。

假如给数据使用==二叉树==这样的数据结构进行存储，如下图所示

![image-20220607210859663](第06章_索引的数据结构.assets\image-20220607210859663.png)

对字段`Col2`添加了索引，就相当于在磁盘上为`Col2`维护了一个索引的数据结构，即这个==二叉搜索树==。二叉搜索树的每个结点存储的是==(K, V)结构==，`key`是`Col2`，`value`是该`key`所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是==(34, 0x07)==。现在对`Col2`添加了索引，这时再去查找`Col2 = 89`这条记录时会先查找该二叉搜索树（二叉树的遍历查找）。读`34`到内存，`89>34`；继续右侧数据，读`89`到内存，`89==89`；找到数据返回，找到之后就根据当前结点的`value`快速定位到要查找的记录对应的地址。可以发现，只需要==查找两次==就可以定位到记录的地址，查询速度就提高了。

这就是为什么要建索引，目的就是为了==减少磁盘I/O的次数==，加快查询速率。

## 2.索引及其优缺点

---

### 2.1 索引概述

`MySQL`官方对索引的定义为：**索引（index）是帮助`MySQL`高效获取数据的数据结构**。

**索引的本质**：索引是数据结构。可以简单理解为"排好序的快速查找数据结构"，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现==高级查找算法==。

==索引是在存储引擎中实现的==，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的==最大索引数==和==最大索引长度==。所有存储引擎支持每个表至少`16`个索引，总索引长度至少为`256`字节。有些存储引擎支持更多的索引数和更大的索引长度。

### 2.2 优点

1. 类似于大学图书馆建书目索引，提高数据检索的效率，降低==数据库的IO成本==，这也是创建索引最主要的原因。
2. 通过创建唯一索引，可以保证数据库表中每一行==数据的唯一性==。
3. 在实现数据的参考完整性方面，可以==加速表和表之间的连接==。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著==减少查询中分组和排序的时间==，降低了`CPU`的消耗。

### 2.3 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面：

1. 创建索引和维护索引要==消耗时间==，并且随着数据量的增加，所消耗的时间也会增加。
2. 索引需要占==磁盘空间==，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，==存储在磁盘上==，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
3. 虽然索引大大提高了查询速度，同时却会==降低更新表的速度==。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

> 提示：
>
> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。

## 3.InnoDB中索引的推演

---

### 3.1 索引之前的查找

先来看一个精确匹配的例子：

```mysql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

#### 1.在一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录时可以根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

  可以在页目录中使用==二分法==快速定位到对应的槽，然后再遍历该槽对应分组中的记录，即可快速找到指定的记录。

- 以其他列作为搜索条件

  因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从==最小记录==开始==依次遍历==单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很明显，这种查找的效率是非常低的。

#### 2.在很多页中查找

大部分情况下表中存放的记录都非常多的，需要许多的数据页来存储这些记录，在很多页中查找记录的话可以分为两个步骤：

1. 定位到记录所在页
2. 从所在的页内中查找相应的记录

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能==从第一个页==沿着==双向链表==一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是==超级耗时==的。如果一个表有一亿条记录呢？此时==索引==应运而生。

![image-20220608122046686](第06章_索引的数据结构.assets\image-20220608122046686.png)

### 3.2 设计索引

创建一个表：

```mysql
mysql> create table index_demo(
	-> 	c1 int,
	-> 	c2 int,
	->  c3 char(1)
	->  primary key(c1)
	-> ) row_format = Compact;
```

这个新建的`index_demo`表中有2个`INT`类型的列，1个`CHAR(1)`类型的列，而且规定了`c1`列为主键，这个表使用`Compact`行格式来实际存储记录的。这里简化了`index_demo`表的行格式示意图：

![image-20220608122553497](第06章_索引的数据结构.assets\image-20220608122553497.png)

只在示意图中展示记录的这几个部分：

- `record_type`：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1表示目录项记录
- `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用箭头来表明下一条记录是谁。
- `各个列的值`：这里只记录在`index_demo`表中的三个列，分别是`c1`、`c2`和`c3`。
- `其他信息`：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

![image-20220608123608259](第06章_索引的数据结构.assets\image-20220608123608259.png)

把一些记录放到页里的示意图就是：

![image-20220608123649761](第06章_索引的数据结构.assets\image-20220608123649761.png)

#### 1.一个简单的索引设计方案

在根据某个索引条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们==想快速的定位到需要查找的记录在哪些数据页==中该咋办？可以为快速定位记录所在的数据页而==建立一个目录==，建这个目录必须完成下边这些事：

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**。

  假设：每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下很多记录）。有了这个假设之后我们向`index_demo`表插入3条记录：

  ```mysql
  mysql> insert into index_demo values(1,4,'u'),(3,9,'d'),(5,3,'y');
  Query OK, 3 rows affected (0.01 sec)
  Records: 3 Duplicates: 0 Warnings: 0
  ```

  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：

  ![image-20220608182913408](第06章_索引的数据结构.assets\image-20220608182913408.png)

  从图中可以看出，`index_demo`表中的3条记录都被插入到了编号为`10`的数据页中了。此时再插入一条记录：

  ```mysql
  mysql> INSERT INTO index_demo VALUES(4,4,'a');
  ```

  因为`页10`最多只能放3条记录，所以不得不再分配一个新页：

  ![image-20220608183203337](第06章_索引的数据结构.assets\image-20220608183203337.png)

  注意，新分配的==数据页编号==可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了==链表==关系。另外，`页10`中用户记录最大的主键值是`5`，而`页28`中有一条记录的主键值是`4`，因为`5 > 4`，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为`4`的记录时需要伴随着一次==记录移动==，也就是把主键值为`5`的记录移动到页`28`中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

  ![image-20220608184836834](第06章_索引的数据结构.assets\image-20220608184836834.png)

  这个过程表明了在对页中的记录进行增删改操作的过程中，必须通过一些诸如==记录移动==的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为==页分裂==。

- **给所有的页建立一个目录项**。

  由于数据页的==编号可能是不连续==的，所以在向`index_demo`表中插入许多条记录后，可能是这样的效果：

  ![image-20220608185324911](第06章_索引的数据结构.assets\image-20220608185324911.png)

  因为这些`16KB`的页在物理存储上是==不连续==的，所以如果想从这么多页中根据主键值==快速定位某些记录所在的页==，需要给它们做个==目录==，每个页对应一个目录项，每个目录项包括下边两个部分：

  - 页的用户记录中最小的主键值，用`key`来表示。
  - 页号，用`page_no`表示。

  所以为上边几个页做好的目录就像这样子：

  ![image-20220608185814460](第06章_索引的数据结构.assets\image-20220608185814460.png)

  以`页28`为例，它对应==目录项2==，这个目录项中包含着该页的页号`28`以及该页中用户记录的最小主键值`5`。只需要把这几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为`20`的记录，具体查找过程分两步：

  1. 先从目录项中根据==二分法==快速确定出主键值为`20`的记录在==目录项3==中（因为`12 < 20 < 200`），它对应的页是`页9`。
  2. 再根据前边说的在页中查找记录的方式去`页9`中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有个别名，称为==索引==。

#### 2.`InnoDB`的索引方案

##### ① 迭代1次：目录项记录的页

上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用==二分法==快速定位具体的目录项而==假设==所有目录项都可以在物理存储器上==连续存储==，但是这样做有几个问题：

- `InnoDB`是使用页来作为管理存储空间的基本单位，最多能保证`16KB`的连续存储空间，而随着表中记录数量增多，需要==非常大的连续的存储空间==才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。
- 我们时常会对==记录进行增删==，假设把`页28`中的记录都删除了，那意味着==目录项2==也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。

所以，需要一种可以==灵活管理所有目录项==的方式。发现目录项其实长得跟用户记录差不多，只不过目录项中的两个列是==主键==和==页号==而已，为了和用户记录做一下区分，把这些用来表示目录项的记录称为==目录项记录==。那`InnoDB`怎么区分一条记录是普通的==用户记录==还是==目录项记录==呢？使用记录头信息里的`record_type`属性，它的各个取值代表的意思如下：

- 0：普通用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

把前边使用到的目录项放到数据页中的样子就是这样：

![image-20220608200218397](第06章_索引的数据结构.assets\image-20220608200218397.png)

从图中可以看出来，新分配了一个编号为`30`的页来专门存储目录项记录。这里再次强调==目录项记录==和普通的==用户记录==的**不同点**：

- ==目录项记录==的`record_type`值是1，而==普通用户记录==的`record_type`值是0。
- 目录项记录只有==主键值和页的编号==两个列，而普通的用户记录的列是用户自己定义的，可能包含==很多列==，另外还有`InnoDB`自己添加的隐藏列。
- 了解：记录头信息里还有一个叫`min_rec_mask`的属性，只有在存储==目录项记录==的页中的主键值最小的==目录项记录==的`min_rec_mask`值是`1`，其他别的记录的`min_rec_mask`值都是`0`。

**相同点**：两者用的是一样的数据页，都会为主键值生成`Page Directory`（页目录），从而在按照主键值进行查找时可以使用==二分法==来加快查询速度。

现在以查找主键为`20`的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

1. 先到存储==目录项记录==的页，也就是页`30`中通过==二分法==快速定位到对应目录项，因为`12 < 20 <200`，所以定位到对应的记录所在的页就是页`9`。
2. 再到存储用户记录的页`9`中根据==二分法==快速定位到主键值为`20`的用户记录。

##### ② 迭代2次：多个目录项记录的页

虽然说==目录项记录==中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说，一个页只有`16KB`大小，能存放的==目录项记录==也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的==目录项记录==，如何处理呢？

这里假设一个存储目录项记录的页==最多只能存放4条目录项记录==，所以如果此时再向上图中插入一条主键值为`320`的用户记录的话，那就需要分配一个新的存储==目录项记录==的页：

![image-20220608202224166](第06章_索引的数据结构.assets\image-20220608202224166.png)

从图中可以看出，插入了一条主键值为`320`的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了`页31`。
- 因为原先存储目录项记录的==页30的容量已满==（先前假设只能存储4条目录项记录），所以不得不需要一个新的`页32`来存放`页31`对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为`20`的记录为例：

1. 确定==目录项记录页==

   现在的存储目录项记录的页有两个，即`页30`和`页32`，又因为`页30`表示的目录项的主键值的范围是`[1,320)`，`页32`表示的目录项的主键值不小于`320`，所以主键值为`20`的记录对应的目录项记录在`页30`中。

2. 通过目录项记录页==确定用户记录真实所在的页==

   在一个存储==目录项记录==的页中通过主键值定位一条目录项记录的方式说过了。

3. 在真实存储用户记录的页中定位到具体的记录

##### ③ 迭代3次：目录项记录页的目录页

问题来了，在这个查询步骤的第1步中需要定位存储目录项记录的页，但是这些==页是不连续的==，如果表中的数据非常多则会==产生很多存储目录项记录的页==，那怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个==更高级的目录==，就像一个多级目录一样，==大目录里嵌套小目录==，小目录里才是真实的数据，所以现在各个页的示意图就是这样子：

![image-20220608210346731](第06章_索引的数据结构.assets\image-20220608210346731.png)

如图，生成了一个存储更高级目录项的`页33`，这个页中的两条记录分别代表`页30`和`页32`，如果用户记录的主键值在`[1, 320)`之间，则到`页30`中查找更详细的目录项记录，如果主键值==不小于320==的话，就在`页32`中查找更详细的目录项记录。

随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么可以用下边这个图来描述它：

![image-20220608204028972](第06章_索引的数据结构.assets\image-20220608204028972.png)

这个数据结构，它的名称是`B+树`。

##### ④ `B+Tree`

不论是存放==用户记录==的数据页，还是存放==目录项记录==的数据页，都把它们存放在`B+Tree`这个数据结构中了，所以我们也称这些数据页为==节点==。从图中可以看出，实际用户记录其实都存放在`B+Tree`的最底层的节点上，这些节点也被称为==叶子节点==，其余用来存放==目录项==的节点称为==非叶子节点==或者==内节点==，其中`B+Tree`最上边的那个节点称为==根节点==。

一个`B+Tree`的节点其实可以分为好多层，规定最下边的那层，也就是存放用户记录的那层为第`0`层，之后一次往上加。之前做了一个非常极端的假设：存放用户记录的页==最多存放3条记录==，存放目录项记录的页==最多存放4条记录==。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放`100条用户记录`，所有存放目录项记录的内节点代表的数据页可以存放`1000条目录项记录`，那么：

- 如果`B+Tree`只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。
- 如果`B+Tree`有2层，最多能存放`1000×100=100000`条记录。
- 如果`B+Tree`有3层，最多能存放`1000×1000×100=100000000`条记录。
- 如果`B+Tree`有4层，最多能存放`1000×1000×1000×100=1000,000,0000`条记录。相当多的记录！！

表里能存放`10000000000`条记录吗？所以一般情况下，我们==用到的B+Tree都不会超过4层==，那通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录页和一个用户记录页），又因为在每个页面内有所谓的`Page Directory`（页目录），所以在页面内也可以通过==二分法==实现快速定位记录。

### 3.3 常见索引概念

索引按照物理实现方式，索引可以分为`2`种：聚簇（聚集）和非聚簇（非聚集）索引。也把非聚集索引称为二级索引或者辅助索引。

#### 1.聚簇索引

**聚簇索引**并不是一种单独的索引类型，而是**一种数据存储方式**（所有的用户记录都存储在了叶子节点），也就是所谓的==索引即数据，数据即索引==。

> 术语"聚簇"表示数据行和相邻的键值聚簇的存储在一起

**特点**：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
   - ==页内==的记录是按照主键的大小顺序排成一个==单向链表==。
   - 各个存放==用户记录的页==也是根据页中用户记录的主键大小顺序排成一个==双向链表==。
   - 存放==目录项记录的页==分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个==双向链表==。

2. `B+Tree`的==叶子节点==存储的是完整的用户记录。

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的`B+Tree`称为==聚簇索引==，所有完整的用户记录都存放在这个==聚簇索引==的叶子节点处。这种聚簇索引并不需要再`MySQL`语句中显式的使用`INDEX`语句去创建，`InnoDB`存储引擎会==自动==的为我们创建聚簇索引。

**优点**：

- ==数据访问更快==，因为聚簇索引将索引和数据保存在同一个`B+Tree`中，因此从聚簇索引中获取数据比非聚簇索引更快。

- 聚簇索引对于主键的==排序查找==和==范围查找==速度非常快。
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以==节省了大量的IO操作==。

**缺点**：

- ==插入速度严重依赖于插入顺序==，按照主键的顺序插入是最快速的方式，否则将会出现页分裂，严重影响性能，因此，对于`InnoDB`表，一般都会定义一个**自增的`ID`列为主键**。
- ==更新主键的代价很高==，因为将会导致被更新的行移动。因此，对于`InnoDB`表，我们一般定义**主键为不可更新**。
- ==二级索引访问需要两次索引查找==，第一次找到主键值，第二次根据主键值找到行数据。

**限制**：

- 对于`MySQL`数据库目前只有`InnoDB`数据引擎支持聚簇索引，而`MyISAM`并不支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以每个`MySQL`的==表只能有一个聚簇索引==。一般情况下就是该表的主键。
- 如果没有定义主键，`InnoDB`会选择==非空的唯一索引==替代。如果没有这样的索引，`InnoDB`会隐式的定义一个主键来作为聚簇索引。
- 为了充分利用聚簇索引的聚簇的特性，所以`InnoDB`表的主键列尽量==选用有序的顺序id==，而不建议用无序的`id`，比如`UUID`、`MD5`、`HASH`、字符串列作为主键，它们无法保证数据的顺序增长。

#### 2.二级索引（辅助索引、非聚簇索引）

上边介绍的==聚簇索引==只能在搜索条件是==主键值==时才能发挥作用，因为`B+Tree`中的数据都是按照主键进行排序的。那如果想以别的列作为搜索条件该怎么办呢？肯定不能从头到尾沿着链表依次遍历记录。

答案：可以==多建几个B+Tree==，不同的`B+Tree`中的数据采用不同的排序规则。比方说`c2`列的大小作为数据页、页中记录的排序规则，再建一个`B+Tree`，效果如下图所示：

![image-20220608214607000](第06章_索引的数据结构.assets\image-20220608214607000.png)

这个`B+Tree`与上面介绍的聚簇索引有几处不同：

- 使用记录`c2`列的大小进行记录和页的排序，这包括三个方面的含义：
  - 页内的记录是按照`c2`列的大小排序排成一个==单向链表==。
  - 各个存放==用户记录的页==也是根据页中记录的`c2`列大小顺序排成一个==双向链表==。
  - 存放==目录项记录的页==分为不同的层次，在同一层次中的页也是根据页中目录项记录的`c2`列大小顺序排成一个==双向链表==。

- `B+Tree`的叶子节点存储的并不是完整的用户记录，而只是==c2列+主键==这两个列的值。
- 目录项记录中不再是==主键+页号==的搭配，而变成了==c2列+页号==的搭配。

所以如果现在想通过`c2`列的值查找某些记录的话就可以使用刚刚建好的这个`B+Tree`。以查找`c2`列的值为`4`的记录为例，查找过程如下：

1. 确定==目录项记录页==。

   根据==根页面==，也就是`页44`，可以快速定位到==目录项记录==所在的页为`页42`（因为`2 < 4 < 9`）。

2. 通过==目录项记录页==确定用户记录真实所在的页。

   在`页42`中可以快速定位到实际存储用户记录的页，但是由于`c2`列并没有唯一性约束，所以`c2`列值为`4`的记录可能分布在多个数据页中，又因为`2 < 4 <= 4`，所以确定实际存储用户记录的页在`页34`和`页35`中。

3. 在真实存储用户记录的页中定位到具体的记录。

   到`页34`和`页35`中定位到具体的记录。

4. 但是这个`B+Tree`的叶子节点中的记录只存储了`c2`和`c1`（也就是==主键==）两个列，所以必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。

**概念：回表**

根据这个以`c2`列大小排序的`B+Tree`只能确定要查找记录的主键值，所以如果想根据`c2`列的值查找到完整的用户记录的话，仍然需要到==聚簇索引==中再查一遍，这个过程称为==回表==，也就是根据`c2`列的值查询一条完整的用户记录需要使用到`2`个`B+Tree`！

**问题**：为什么还需要一次==回表==操作呢？直接把完整的用户记录放到叶子节点不OK吗？

**回答**：

如果把完整的用户记录放在叶子节点中是可以不用回表，但是==太占地方==了，相当于每创建一个`B+Tree`都需要把所有的用户记录再都拷贝一遍，这就太浪费存储空间了。

因为这种按照==非主键列==建立的`B+Tree`需要一次回表操作才可以定位到完整的用户记录，所以这种`B+Tree`也被称为==二级索引==（英文名`secondary_index`），或者==辅助索引==。由于我们使用的是`c2`列的大小作为`B+Tree`的排序规则，所以也称这个`B+Tree`是为`c2`列建立的索引。

非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![image-20220608221020220](第06章_索引的数据结构.assets\image-20220608221020220.png)

小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：

1. 聚簇索引的==叶子节点==存储的就是==数据记录==，非聚簇索引的叶子节点存储的是==数据位置==。非聚簇索引不会影响数据表的物理存储顺序。
2. 一个表==只能有一个聚簇索引==，因为只能有一种排序存储的方式，但可以有==多个非聚簇索引==，也就是多个索引目录提供数据检索。
3. 使用聚簇索引时，数据的==查询效率高==，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

#### 3.联合索引

也可以同时以多个列的大小作为排序规则，也就是同时为多个列创建索引，比方说想让`B+Tree`按照==c2和c3列==的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照`c2`列进行排序。
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序

为`c2`和`c3`列建立的索引的示意图如下：

![image-20220608222035876](第06章_索引的数据结构.assets\image-20220608222035876.png)

如图所示，需要注意以下几点：

- 每条==目录项记录==都由`c2`、`c3`、`页号`这三个部分组成，各条记录先按照`c2`列的值进行排序，如果记录的`c2`列相同，则按照`c3`列的值进行排序。
- `B+Tree`==叶子节点==处的用户基于由`c2`、`c3`、`主键c1`组成。

注意一点，以`c2`和`c3`列的大小为排序规则建立的`B+Tree`称为==联合索引==，本质上也是一个二级索引。它的意思与分别为`c2`和`c3`列分别建立索引的表述是不同的，不同点如下：

- 建立==联合索引==只会建立如上图一样的1个`B+Tree`。
- 为`c2`和`c3`列分别建立索引会分别以`c2`和`c3`列的大小为排序规则建立2个`B+Tree`。

### 3.4 `InnoDB`的`B+Tree`索引的注意事项

#### 1.根页面位置万年不动

前面介绍`B+Tree`索引时，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上`B+Tree`形成过程是这样的：

- 每当为某个表创建一个`B+Tree`索引（聚簇索引不是人为创建的，默认就有）时，都会为这个索引创建一个==根节点==页面。最开始表中没有数据的时候，每个`B+Tree`索引对应的==根节点==中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个==根节点==中。
- 当根节点中的可用==空间用完时==继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如==页a==中，然后对这个新页进行==页分裂==的操作，得到另一个新页，比如==页b==。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到==页a==或者==页b==中，而==根节点==便升级为存储目录项记录的页。

这个过程特别注意的是：一个`B+Tree`索引的根节点自诞生之日起，便不会再移动。这样只要对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是`InnoDB`存储引擎需要用到这个索引时，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

#### 2.内节点中目录项记录的唯一性

`B+Tree`索引的内节点中目录项记录的内容是==索引列+页号==的搭配，但是这个搭配对于二级索引来说有点不严谨，还拿`index_demo`表为例，假设这个表中的数据是这样的：

| c1   | c2   | c3   |
| ---- | ---- | ---- |
| 1    | 1    | ‘u’  |
| 3    | 1    | ‘d’  |
| 5    | 1    | ‘y’  |
| 7    | 1    | ‘a’  |

如果二级索引中目录项记录的内容只是==索引列+页号==的搭配的话，那么为`c2`列建立索引后的`B+Tree`应该长这样：

![image-20220608225435678](第06章_索引的数据结构.assets\image-20220608225435678.png)

如果想新插入一行记录，其中`c1、c2、c3`的值分别是`9、1、'c'`，那么在修改这个为`c2`列创建的二级索引对应的`B+Tree`时便碰到一个大问题：由于`页3`中存储的目录项记录是由==c2列+页号==的值构成的，`页3`中的两条目录项记录对应的`c2`列的值都是`1`，而==新插入的这条记录==的`c2`列的值也是`1`，那这条心插入的记录到底应该放在`页4`中，还是应该放到`页5`中呢？答案是：懵了。

为了让新插入记录能找到自己在哪个页里，需要**保证在`B+Tree`的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三部分构成的：

- 索引列的值
- 主键值
- 页号

也就是把==主键值==也添加到二级索引内节点中的目录项记录中，这样就能保证`B+Tree`每一层节点中各条目录项记录除页号这个字段外是唯一的，所以为`c2`列建立二级索引后的示意图实际上应该是这样的：

![image-20220608230756181](第06章_索引的数据结构.assets\image-20220608230756181.png)

这样再插入记录`(9, 1, 'c')`时，由于`页3`中存储的目录项记录是由==c2列+主键+页号==的值构成的，可以先把新记录的`c2`列的值和`页3`中各目录项记录的`c2`列的值作比较，如果`c2`列的值相同的话，可以接着比较主键值，因为`B+Tree`同一层中不同目录项记录的==c2列+主键==的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到`页5`中。

#### 3.一个页面最少存储2条记录

一个`B+Tree`只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为`B+Tree`本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果？那就是目录层级非常非常的多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？所以==InnoDB的一个数据页至少可以存放两条记录==。

## 4.MyISAM中的索引方案

---

**`B-Tree`索引适用存储引擎如表所示**：

| 索引/存储引擎 | MyISAM | InnoDB | Memory |
| ------------- | ------ | ------ | ------ |
| `B-Tree`索引  | 支持   | 支持   | 支持   |

即便多个存储引擎支持同一种类型的索引，但是它们的实现原理也是不同的。`InnoDB`和`MyISAM`默认的索引是`B-Tree`索引；而`Memory`默认的索引是`Hash`索引。

`MyISAM`引擎使用`B+Tree`作为索引结果，叶子节点的`data`域存放的是==数据记录的地址==。

### 4.2 `MyISAM`索引的原理

下图是`MyISAM`索引的原理图。

`InnoDB`中索引即数据，也就是聚簇索引的那个`B+Tree`的叶子节点中已经把所有完整的用户记录都包含了，而`MyISAM`的索引方案虽然也使用树形结构，但是却==将索引和数据分开存储==：

- 将表中的记录==按照记录的插入顺序==单独存储在一个文件中，称之为==数据文件==。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据时并==没有刻意按照主键大小排序==，所以并不能在这些数据上使用二分法进行查找。
- 使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为==索引文件==的文件中。`MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是==主键值+数据记录地址==的组合。

![image-20220609091334863](第06章_索引的数据结构.assets\image-20220609091334863.png)

这里设表一共有三列，假设我们以`Col1`为主键，上图是一个`MyISAM`表的主索引（Primary Key）示意。可以看出**`MyISAM`的索引文件仅仅保存数据记录的地址**。在`MyISAM`中，主键索引和二级索引（Secondary key）在结构上没有任何区别，只是主键索引要求`key`是唯一的，而二级索引的`key`可以重复。如果在`Col2`上建立一个二级索引，则此索引的结构如下图所示：

![image-20220609095944082](第06章_索引的数据结构.assets\image-20220609095944082.png)

同样也是一个`B+Tree`，`data`域保存数据记录的地址。因此，`MyISAM`中索引检索的算法为：首先按照`B+Tree`搜索算法搜索索引，如果指定的`key`存在，则取出其`data`域的值，然后以`data`域的值为地址，读取相应数据记录。

### 4.3 `MyISAM`与`InnoDB`对比

**`MyISAM`的索引方式都是"非聚簇"的，与`InnoDB`包含1个聚簇索引是不同的。**

小结两种引擎中索引的区别：

① 在`InnoDB`存储引擎中，只需要根据主键值对==聚簇索引==进行一次查找就能找到对应的记录，而在`MyISAM`中却需要进行一次==回表==操作，意味着`MyISAM`中建立的索引相当于全部都是==二级索引==。

② `InnoDB`的数据文件本身就是索引文件，而`MyISAM`索引文件和数据文件的==分离的==，索引文件仅保存数据记录的地址。

③ `InnoDB`的非聚簇索引`data`域存储相应记录==主键的值==，而`MyISAM`索引记录的是==地址==。换句话说，`InnoDB`的所有非聚簇索引都引用主键作为`data`域。

④ `MyISAM`的回表操作是十分==快速==的，因为是拿着地址偏移量直接到文件中取数据的。反观`InnoDB`是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ `InnoDB`要求表==必须有主键（MyISAM可以没有）==。如果没有显式指定，则`MySQL`系统自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这个列，则`MySQL`自动为`InnoDB`表生成一个隐含字段作为主键，这个字段长度为`6`个字节，类型为长整形。

**小结**：

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助的。比如：

举例1：知道了`InnoDB`的索引实现后，就很容易明白==为什么不建议使用过长的字段作为主键==。因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。

举例2：用非单调的字段作为主键在`InnoDB`中不是好主意，因为`InnoDB`数据文件本身是一个`B+Tree`，非单调的主键会造成在插入新纪录时，数据文件为了维持`B+Tree`的特性而频繁的分裂调整，十分低效，而使得==自增字段作为主键则是一个很好的选择==。

![image-20220609102457493](第06章_索引的数据结构.assets\image-20220609102457493.png)

## 5.索引的代价

---

索引是个好东西，可不能乱建，它的空间和时间上都会有消耗：

- **空间上的代价**

  每建立一个索引都要为它建立一个`B+Tree`，每一个`B+Tree`的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一个很大的`B+Tree`由许多数据页组成，那就是很大的一片存储空间。

- **时间上的代价**

  每次对表中的数据进行==增、删、改==操作时，都需要去修改各个`B+Tree`索引。`B+Tree`每层节点都是按照索引列的值==从小到大的顺序排序==而组成了==双向链表==。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些==记录移位==，==页面分裂==、==页面回收==等操作来维护好节点和记录的排序。如果建了很多索引，每个索引对应的`B+Tree`都要进行相关的维护操作，会给性能拖后腿。

> 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录时性能就越差。为了能建立又好又少的索引，就要学会哪些索引在哪些条件下起作用。

## 6.MySQL数据结构选择的合理性

---

从`MySQL`的角度讲，不得不考虑一个现实问题就是磁盘`I/O`。如果能让索引的数据结构尽量减少磁盘的`I/O`操作，所消耗的时间就越小。可以说，==磁盘的 I/O 操作次数==对索引的使用效率至关重要。

查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量较大时，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，**数据库索引是存储在外部磁盘上的**。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能==逐一加载==，那么`MySQL`衡量查询效率的标准是磁盘`I/O`次数。

### 6.1 全表遍历

略

### 6.2 `Hash`结构

`Hash`本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。

`Hash`算法是通过某种确定性的算法（比如`MD5`、`SHA1`、`SHA2`、`SHA3`）将输入转为输出。==相同的输入永远可以得到相同的输出==，假设输入内容有微小偏差，在输出中通常会有不同的结果。

举例：如果想要验证两个文件是否相同，那么不需要把两份文件直接拿来对比，只需要让对方把`Hash`函数计算得到的结果告诉你即可，然后在本地同样对文件进行`Hash`函数的运算，最后通过比较这两个`Hash`函数的结果是否相同，就可以知道这两个文件是否相同。

**加速查找速度的数据结构，常见的有两类**：

（1）树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是`O(log2N)`；

（2）哈希，例如`HashMap`，查询/插入/修改/删除的平均时间复杂度都是`O(1)`；

![image-20220609110341159](第06章_索引的数据结构.assets\image-20220609110341159.png)

采用`Hash`进行检索效率非常高，基本上一次检索就可以找到数据，而`B+Tree`需要自顶而下一次查找，多次访问节点才能找到数据，中间需要多次`I/O`操作，==从效率来说 Hash 比 B+Tree 更快==。

在哈希的方式下，一个元素`k`处于`h(k)`中，即利用哈希函数`h`，根据关键字`k`计算出槽的位置。函数`h`将关键字域映射到哈希表`T[0...m-1]`的槽位上。

![image-20220609110956701](第06章_索引的数据结构.assets\image-20220609110956701.png)

上图中哈希函数`h`有可能将两个不同的关键字映射到相同的位置，这叫做==碰撞==，在数据库中一般采用==链接法==来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：

![image-20220609111251268](第06章_索引的数据结构.assets\image-20220609111251268.png)

实验：体会数组和`hash`表的查找方面的效率区别

```java
// 算法复杂度为O(n)
@Test
public void test1() {
    int[] arr = new int[100000];
    for(int i = 0; i < arr.length; i++) {
        arr[i] = i + 1;
    }
    
    long start = System.currentTimeMillis();
    for(int j = 1; j <= 100000; j++) {
        int temp = j;
        
        for(int i = 0; i < arr.length; i++) {
            if(temp == arr[i]) {
                break;
            }
        }
    }
    long end = System.currentTimeMillis();
    System.out.println("time: " + (end - start)); // time: 823ms
}
```

```java
// 算法复杂度为O(1)
@Test
public void test2() {
    HashSet<Integer> set = new HashSet<>(100000);
    for(int i = 0; i < 100000; i++) {
        set.add(i + 1);
    }
    
    long start = System.currentTimeMillis();
    for(int j= 1; j <= 100000; j++) {
        int temp = j;
        boolean contains = set.contains(temp);
    }
    long end = System.currentTimeMillis();
    System.out.println("time: " + (end - start)); // time: 5ms
}
```

**`Hash`结构效率高，那为什么索引结构要设计成树型呢？**

原因1：`Hash`索引仅能满足`=`、`<>`和`IN`查询。如果进行==范围查询==，哈希型的索引，时间复杂度会退化为`O(n)`；而树型的"有序"特性，依然能够保持`O(log2N)`的高效率。

原因2：`Hash`索引还有一个缺陷，数据的存储是==没有顺序的==，在`ORDER BY`的情况下，使用`Hash`索引还需要对数据重新排序。

原因3：对于联合索引的情况，`Hash`值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。

原因4：对于等值查询来说，通常`Hash`索引的效率更高，不过也存在一种情况，就是==索引列的重复值如果很多，效率就会降低==。这是因为遇到`Hash`冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，`Hash`索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。

**`Hash`索引适用存储引擎如表所示**：

| 索引/存储引擎 | MyISAM | InnoDB | Memory |
| ------------- | ------ | ------ | ------ |
| Hash索引      | 不支持 | 不支持 | 支持   |

**`Hash`索引的适用性**：

`Hash`索引存在着很多限制，相比之下在数据库中`B+Tree`索引的使用面会更广，不过也有一些场景采用`Hash`索引效率更高，比如在键值型（Key-Value）数据库中，==Redis 存储的核心就是 Hash 表==。

`MySQL`中的`Memory`存储引擎支持`Hash`存储，如果需要用到查询的临时表时，就可以选择`Memory`存储引擎，把某个字段设置为`Hash`索引，比如字符串类型的字段，进行`Hash`计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行==等值查询==时，采用`Hash`索引是个不错的选择。

另外，`InnoDB`本身不支持`Hash`索引，但是提供==自适应 Hash 索引==（Adaptive Hash Index）。什么情况下才会使用适应`Hash`索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到`Hash`表中。这样下次查询时，就可以直接找到这个页面的所在位置，这样让`B+Tree`也具备了`Hash`索引的优点。

![image-20220609114343911](第06章_索引的数据结构.assets\image-20220609114343911.png)

采用自适应`Hash`索引目的是方便根据`SQL`的查询条件加速定位到叶子节点，特别是当`B+Tree`比较深的时候，通过自适应`Hash`索引可以明显提高数据的检索效率。

可以通过`innodb_adaptive_hash_index`变量来查看是否开启了自适应`Hash`，比如：

```mysql
mysql> show varibales like '%adaptive_hash_index';
```

![image-20220609114740027](第06章_索引的数据结构.assets\image-20220609114740027.png)

### 6.3 二叉搜索树

如果利用二叉树作为索引结构，那么磁盘的`I/O`次数和索引树的高度是相关的。

1. **二叉搜索树的特点**
   - 一个节点只能有两个子节点，也就是一个节点度不能超过2
   - 左子节点<本节点；右子节点>=本节点，比我大的向右，比我小的向左

2. **查询规则**

   先来看下最基础的二叉搜索树（Binary Search Tree），搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为`key`：

   1. 如果`key`大于根节点，则在右子树中进行查找；
   2. 如果`key`小于根节点，则在左子树中进行查找；
   3. 如果`key`等于根节点，也就是找到了这个节点，返回根节点即可。

   举个例子，对数列`(34, 22, 89, 5, 23, 77, 91)`创造出来的二分查找树如下图所示：

![image-20220609123851494](第06章_索引的数据结构.assets\image-20220609123851494.png)

但是存在特殊情况，就是有时候二叉树的深度非常大。比如给出的数据顺序是`(5, 22, 23, 34, 77, 89, 91)`，创造出来的二分搜索树如下图所示：

![image-20220609124232676](第06章_索引的数据结构.assets\image-20220609124232676.png)

上面第二个树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了`O(n)`。第一个树的深度是3，也就是说最多只需3次比较，就可以找到节点，而第二树的深度是7，最多需要7次比较才能找到节点。

为了提高查询效率，就需要==减少磁盘IO数==。为了减少磁盘`I/O`的次数，就需要尽量==降低树的高度==，需要把原来"瘦高"的树形结构变的"胖矮"，树的每层的分叉越多越好。

### 6.4 `AVL`树

为了解决上面二叉查找树退化成链表的问题，人们提出了==平衡二叉搜索树（Balanced Binary Tree）==。又称为`AVL`树（有别于`AVL`算法），它在二叉搜索树的基础上增加了约束，具有以下性质：

**它是一个空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一个平衡二叉树**。

这里说一下，常见的平衡二叉树有很多种，包括了==平衡二叉搜索树、红黑树、数堆、伸展树==。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当提到平衡二叉树时一般指的就是平衡二叉搜索树。实际上，第一个树就属于平衡二叉搜索树，搜索时间复杂度就是`O(log2n)`。

数据查询的时间主要依赖于磁盘`I/O`的次数，如果采用二叉树的形式，即便通过平衡二叉搜索树进行了改进，树的深度也是`O(log2N)`，当`N`比较大时，深度也是比较深的，比如下图的情况：

![image-20220609125231473](第06章_索引的数据结构.assets\image-20220609125231473.png)

==每访问一次节点就需要进行一次磁盘 I/O 操作==，对于上面的树来说，需要进行5次`I/O`操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘`I/O`操作次数多，会影响整体数据查询的效率。

针对同样的数据，如果把二叉树改成`M叉树`(M>2)呢？当`M=3`时，同样的`31`个节点可以由下面的三叉树来进行存储：

![image-20220609125540736](第06章_索引的数据结构.assets\image-20220609125540736.png)

此时树的高度降低了，当数据量`N`大的时候，以及树的分叉树`M`大的时候，`M`叉树的高度会远小于二叉树的高度(M>2)。所以，需要把==树从"瘦高"变"矮胖"==。

### 6.5 `B-Tree`

`B树`的英文是`Balance Tree`，也就是==多路平衡查找树==。简写为`B-Tree`（注意横杠表示这两个单词连起来的意思，不是减号）。它的高度远小于平衡二叉树的高度。

`B-Tree`的结构如下图所示：

![image-20220609125927349](第06章_索引的数据结构.assets\image-20220609125927349.png)

`B-Tree`作为多路平衡查找树，它的每一个节点最多可以包括`M`个子节点，==M 称为 B-Tree 的阶==。每个磁盘块中包括了==关键字==和==子节点的指针==。如果一个磁盘块中包括了`x`个关键字，那么指针数就是`x+1`。对于一个`100`阶的`B-Tree`来说，如果有3层的话最多可以存储约`100`万的索引数据。对于大量的索引数据来说，采用`B-Tree`的结构是非常适合的，因为树的高度要远小于二叉树的高度。

一个`M`阶的`B-Tree`(M>2)有以下的特性：

1. 根节点的儿子数的范围是`[2, M]`。
2. 每个中间节点包含`k-1`个关键字和`k`个孩子，孩子的数量=关键字的数量+1，`k`的取值范围是`[ceil(M/2), M]`。
3. 叶子节点包括`k-1`个关键字（叶子节点没有孩子），`k`的取值范围为`[ceil(M/2), M]`。
4. 假设中间节点的关键字为：`Key[1], Key[2], ..., Key[k-1]`，且关键字按照升序排序，即`Key[i]<Key[i+1]`。此时`k-1`个关键字相当于划分了`k`个范围，也就是对应着`k`个指针，即为：`P[1], P[2], ..., P[k]`，其中`P[1]`指向关键字小于`Key[1]`的子树，`P[i]`直线关键字属于`(Key[i-1], Key[i])`的子树，`P[k]`指向关键字大于`Key[k-1]`的子树。
5. 所有叶子节点位于同一层。

上面那张图所表示的`B-Tree`就是一个`3`阶的`B-Tree`。可以看下磁盘块2，里面的关键字是`(8, 12)`，它有`3`个孩子`(3, 5), (9, 10), (13, 15)`，能看到`(3, 5)`小于8，`(9, 10)`在8和12之间，而`(13, 15)`大于12，刚好符合刚才给出的特征。

然后来看下如何用`B-Tree`进行查找。假设想要==查找关键字是9==，那么步骤可以分为以下几步：

1. 我们与根节点的关键字`(17, 35)`进行比较，`9`小于`17`那么得到指针`P1`；
2. 按照指针`P1`找到磁盘块`2`，关键字为`(8, 12)`，因为`9`在`8`和`12`之间，所以得到指针`P2`；
3. 按照指针`P2`找到磁盘块`6`，关键字为`(9, 10)`，然后找到关键字9.

看出来在`B-Tree`的搜索过程中，比较的次数并不多，但如果把数据读取出来然后在内存中进行比较，这个时间就可以忽略不计了。而读取磁盘块本身需要进行`I/O`操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。==B-Tree 相比于平衡二叉树来说磁盘 I/O 操作最少==，在数据查询中比平衡二叉树效率更高。所以==只要树的高度足够低，IO次数足够小，就可以提高查询性能==。

**小结**：

1. `B-Tree`在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。
2. 关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。
3. 其搜索性能等价于在关键字全集内做一次二分查找。

**再举例1**：

![image-20220609132006672](第06章_索引的数据结构.assets\image-20220609132006672.png)

### 6.6 `B+Tree`

`B+Tree`也是一种多路搜索树，==基于 B-Tree 做出了改进==。主流的`DBMS`都支持`B+Tree`的索引方式，比如`MySQL`。相比于`B-Tree`，==B+Tree 适合文件索引系统==。

- `MySQL`官网说明：

![image-20220609132233856](第06章_索引的数据结构.assets\image-20220609132233856.png)

**`B+Tree`和`B-Tree`的差异在于以下几点**：

1. 有`k`个孩子的节点就有`k`个关键字。也就是孩子数量=关键字数，而`B-Tree`中，孩子数量=关键字数+1。
2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。
3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而`B-Tree`中，==非叶子节点既保存索引，也保存数据记录==。
4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

下图就是一个`B+Tree`，阶数为`3`，根节点中的关键字`1、18、35`分别是子节点`(1, 8, 14)`，`(18, 24, 31)`和`(35, 41, 53)`中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。

![image-20220609133338286](第06章_索引的数据结构.assets\image-20220609133338286.png)

比如，想要查找关键字`16`，`B+Tree`会自顶而下逐层进行查找：

1. 与根节点的关键字`(1, 18, 35)`进行比较，`16`在`1`和`18`直接，得到指针`P1`（指向磁盘块2）
2. 找到磁盘块2，关键字为`(1, 8, 14)`，因为`16`大于`14`，所以得到指针`P3`（指向磁盘块7）
3. 找到磁盘块7，关键字为`(14, 16, 17)`，然后找到了关键字`16`，所以可以找到关键字`16`所对应的数据。

整个过程一共进行了`3`次`I/O`操作，看起来`B+Tree`和`B-Tree`的查询过程差不多，但是`B+Tree`和`B-Tree`有个根本的差异在于，**`B+Tree`的中间节点并不直接存储数据**这样的好处都有什么呢？

首先，**`B+Tree`查询效率更稳定**。因为`B+Tree`每次只有访问到叶子节点才能找到对应的数据，而在`B-Tree`中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。

其次，**`B+Tree`的查询效率更高**。这是因为通常`B+Tree`比`B-Tree`==更胖矮==（阶数更大，深度更深），查询所需要的磁盘`I/O`也会更少。同样的磁盘页大小，`B+Tree`可以存储更多的节点关键字。

不仅是对单个关键字的查询上，**在查询范围上，`B+Tree`的效率也比`B-Tree`高**。这是因为所有关键字都出现在`B+Tree`的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查询。而在`B-Tree`中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。

> `B-Tree`和`B+Tree`都可以作为索引的数据结构，在`MySQL`中采用的是`B+Tree`。
>
> 但`B-Tree`和`B+Tree`各有自己的应用场景，不能说`B+Tree`完全比`B-Tree`好，反之亦然。

**思考题：为了减少`I/O`，索引树会一次性加载吗？**

> 1.数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。
>
> 2.当利用索引查询时，是不可能全部几个G的索引都加载进内存的，能做的只是逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

**思考题：`B+Tree`的存储能力如何？为何说一般查找行记录，最多只需`1-3`次磁盘`I/O`**

> `InnoDB`存储引擎中页的大小为`16KB`，一般表的主键类型为`INT`（占用4个字节）或`BIGINT`（占用8个字节），指针类型也一般为`4`或`8`个字节，也就是说一个页（`B+Tree`中的一个节点）中大概存储`16KB/(8B+8B)=1K`个键值（因为是估值，为了方便计算，这里的`K`取值为1000)。也就是说一个深度为3的`B+Tree`索引可以维护`10^3*10^3=10亿`条记录。（这里假定一个数据页页存储10^3条行记录数据）
>
> 实际情况中每个节点可能不能填充满，因此在数据库中，==B+Tree 的高度一般都在 2-4 层==。`MySQL`的`InnoDB`存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要`1-3`次磁盘`I/O`操作。

**思考题：为什么说`B+Tree`比`B-Tree`更适合实际应用中操作系统的文件索引和数据库索引？**

> 1.`B+Tree`的磁盘读写代价更低
>
> `B+Tree`的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对`B-Tree`更小。如果把所有同一内部结点的关键字存放在同一磁盘块中，那么盘快所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说`I/O`读写次数也就降低了。
>
> 2.`B+Tree`的查询效率更加稳定
>
> 由于非叶子节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

**思考题：`Hash`索引与`B+Tree`索引的区别**

> 之前讲到过`B+Tree`索引的结构，`Hash`索引结构和`B+Tree`的不同，因此在索引使用上也会有差别。
>
> 1.`Hash`索引==不能进行范围查询==，而`B+Tree`可以，这是因为`Hash`索引指向的数据是无序的，而`B+Tree`的叶子节点是个有序的链表。
>
> 2.`Hash`索引==不支持联合索引的最左侧原则==（即联合索引的部分索引无法使用）。而`B+Tree`可以。对于联合索引来说，`Hash`索引在计算`Hash`值时要将索引键合并后再一起计算`Hash`值，所以不会针对每个索引单独计算`Hash`值。因此如果用到联合索引的一个或多个索引时，联合索引无法被利用。
>
> 3.`Hash`索引==不支持 ORDER BY 排序==，因为`Hash`索引指向的数据是无序的，因此无法起到排序优化的作用，而`B+Tree`索引数据是有序的，可以起到对该字段`ORDER BY`排序优化的作用。同理，我们也无法用`Hash`索引进行==模糊查询==，而`B+Tree`使用`LIKE`进行模糊查询时，`LIKE`后面后模糊查询（比如`%`结尾）的话就可
>
> 4.`InnoDB`不支持哈希索引

**思考题：`Hash`索引与`B+Tree`索引是在创建索引的时候手动指定的吗？**

> 如果使用的是`MySQL`的话，我们需要了解`MySQL`的存储引擎都支持哪些索引结构，如下图所示（参考来源：https://dev.mysql.com/doc/refman/8.0/en/create-index.html）。如果是其他的`DBMS`，可以参考相关的`DBMS`文档。
>
> ![image-20220609140950090](第06章_索引的数据结构.assets\image-20220609140950090.png)
>
> 针对`InnoDB`和`MyISAM`存储引擎，都会默认采用`B+Tree`，无法使用`Hash`索引。`InnoDB`提供的自适应`Hash`是不需要手动指定的。如果是`Memory/Heap和NDB`存储引擎，是可以进行选择`Hash`索引的。

### 6.7 R树

`R-Tree`在`MySQL`很少使用，仅支持==geometry 数据类型==，支持该类型的存储引擎只有`MyISAM`、`BDB`、`InnoDB`、`NDB`、`ARCHIVE`几种。举个`R-Tree`在现实领域中能够解决的例子：查找`20`英里以内所有的餐厅，如果没有`R-Tree`怎么解决？一般情况下会把餐厅的坐标`(x, y)`分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有`100`家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行的。`R-Tree`就很好的==解决了这种高维空间搜索问题==。它把`B-Tree`的思想很好的扩展到了多维空间，采用了`B-Tree`分割空间的思想，并在添加、删除操作时采用合并、分解节点的方法，保证树的平衡性。因此`R-Tree`就是一个用来==存储高维数据的平衡树==。相对于`B-Tree`，`R-Tree`的优势在于范围查找。

| 索引/存储引擎 | MyISAM | InnoDB | Memory |
| ------------- | ------ | ------ | ------ |
| R-Tree索引    | 支持   | 支持   | 不支持 |

### 6.8 小结

使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当使用索引时，需要平衡索引的利（提升查询效率）与弊（维护索引所需要的代价）。

在实际工作中，还需啊哟基于需求和数据本身的分布情况来确定是否使用索引，尽管==索引不是万能的==，但==数据量大的时候不适应索引是不可想象的==，毕竟索引的本质，是帮助我们提升数据检索的效率。

### 附录：算法的时间复杂度

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。

![image-20220609142123275](第06章_索引的数据结构.assets\image-20220609142123275.png)
