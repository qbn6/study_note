# 第03章_用户与权限管理

**Author**: `GaoFy`

**Reference**: `shk`

**Date**: `2022-06-05`

---

## 1.用户管理

---

`MySQL`用户可以分为==普通用户==和==ROOT用户==。`root`用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。

**`MySQL`提供了许多语句来管理用户账号**，这些语句可以用来管理包括登录和退出`MySQL`服务器、创建用户、删除用户、密码管理和权限管理等内容。

**`MySQL`数据库的安全性需要通过账户管理来保证**

### 1.1 登录`MySQL`服务器

启动`MySQL`服务后，可以通过`mysql`命令来登录`MySQL`服务器，命令如下：

```shell
mysql -h hostname|hostIP -P port -u username -p DatabaseName -e "SQL语句"
```

命令中的参数：

- `-h`参数后面接主机名或主机`IP`，`hostname`为主机，`hostIP`为主机`IP`。
- `-P`参数后面接`MySQL`服务的端口，通过该参数连接到指定的端口。`MySQL`服务的默认端口是`3306`，不使用该参数时自动连接到`3306`端口，`port`为连接的端口号。
- `-u`参数后面接用户名，`username`为用户名
- `-p`参数会提示输入密码
- `DatabaseName`参数指明登录到哪个数据库中。如果没有该参数，就会直接登录到`mysql`数据库中，然后可以使用`USE`命令来选择数据库。
- `-e`参数后面可以直接加`SQL`语句，登录`MySQL`服务器以后即可执行这个`SQL`语句，然后退出`MySQL`服务器。

举例：

```shell
mysql -uroot -p -hlocalhost -P3306 mysql -e "select host, user from user"
```

### 1.2 创建用户

在`MySQL`数据库中，官方推荐使用`CREATE USER`语句创建新用户。`MySQL8`版本移除了`PASSWORD`加密方法，因此不再推荐使用`INSERT`语句直接操作`MySQL`中的`user`表来添加用户。

使用`CREATE USER`语句来创建新用户时，**必须拥有`CREATE USER`权限**。每添加一个用户，`CREATE USER`语句会在`mysql.user`表中添加一条新记录，但是**新创建的账户没有任何权限**。如果添加的账户已经存在，`CREATE USER`语句就会返回一个错误。

`CREATE USER`语句基本语法形式如下：

```mysql
CREATE USER 用户名 [IDENTIFIED BY '密码'][, 用户名 [IDENTIFIED BY '密码']];
```

- 用户名参数表示新建用户的账户，由==用户（User）==和==主机名（Host）==构成；
- “[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用`IDENTIFIED BY`指定明文密码值。
- `CREATE USER`语句可以同时创建多个用户

举例：

```mysql
CREATE USER zhang3 IDENTIFIED BY 'zhang3'; # 默认 host 是 %

CREATE USER 'li4'@'localhost' IDENTIFIED BY 'li4';
```

### 1.3 修改用户

修改用户名：

```mysql
UPDATE mysql.user SET USER='lisi' WHERE USER = 'li4';

FLUSH PRIVILEGES;
```

![image-20220604221810819](第03章_用户与权限管理.assets\image-20220604221810819.png)

### 1.4 删除用户

在`MySQL`数据库中，可以使用`DROP USER`语句来删除普通用户，也可以直接在`mysql.user`表中删除用户。

**方式1：使用`DROP`方式删除（推荐）**

使用`DROP USER`语句删除用户时，必须有`DROP USER`权限。`DROP USER`语句基本语法形式如下：

```mysql
DROP USER user[, user]...;
```

其中，`user`参数是需要删除的用户，由用户的用户名（User）和主机名（Host）组成。`DROP USER`语句可以同时删除多个用户，各用户之间用逗号隔开。

举例：

```mysql
DROP USER lisi; # 默认删除 host 为 % 的用户

DROP USER 'zhang3'@'localhost';
```

![image-20220604222335392](第03章_用户与权限管理.assets\image-20220604222335392.png)

**方式2：使用`DELETE`方式删除**

可以使用`DELETE`语句直接将用户的信息从`mysql.user`表中删除，但必须拥有对`mysql.user`表的`DELETE`权限，`DELETE`语句的基本语法形式如下：

```mysql
DELETE FROM mysql.user WHERE Host = 'hostname' AND User = 'username';
```

`Host`字段和`User`字段是`user`表的联合主键，因此**两个字段的值才能唯一确定一条记录**。

执行完`DELETE`命令后要使用`FLUSH`命令来使用户生效，命令如下：

```mysql
FLUSH PRIVILEGES;
```

举例：

```mysql
DELETE FROM mysql.user WHERE Host = 'localhost' AND User = 'Emily';

FLUSH PRIVILEGES;
```

> 注意：不推荐通过`DELETE FROM USER u WHERE USER = 'li4'`进行删除，系统会有残留信息保留，而`DROP USER`命令会删除用户以及对应的权限，执行命令后会发现`mysql.user`表和`mysql.db`表的相应记录都消失了。

### 1.5 设置当前用户密码

适用于`root`用户修改自己的密码，以及普通用户登录后修改自己的密码。

`root`用户拥有很高的权限，因此必须保证`root`用户的密码安全。`root`用户可以通过多种方式来修改密码，使用`ALTER USER`修改用户密码是`MySQL`==官方推荐==的方式。此外，也可以通过`SET`语句修改密码。由于`MySQL8`中已移除了`PASSWORD()`函数，因此不再使用`UPDATE`语句直接操作用户表修改密码。

==旧的写法如下==：

```mysql
# 修改当前用户的密码：（MySQL 5.7 测试有效）
SET PASSWORD = PASSWORD('123456');
```

这里介绍==推荐的写法==：

**1.使用`ALTER USER`命令来修改当前用户密码**

用户可以使用`ALTER`命令来修改自身密码，如下语句代表修改当前登录用户的密码。基本语法如下：

```mysql
ALTER USER USER() IDENTIFIED BY 'new_password';
```

**2.使用`SET`语句来修改当前用户密码**

使用`root`用户登录`MySQL`后，可使用`SET`语句来修改密码，具体`SQL`语句如下：

```mysql
SET PASSWORD = 'new_password';
```

该语句会自动将密码加密后再赋给当前用户。

### 1.6 修改其他用户密码

`root`用户不仅可以修改自己的密码，还可以修改其他普通用户的密码。`root`用户登录`MySQL`服务器后，可以通过`ALTER`语句和`SET`语句来修改普通用户的密码，由于`PASSWORD()`函数已移除，因此使用`UPDATE`直接操作用户表的方式不再使用。

**1.使用`ALTER`语句来修改普通用户的密码**

基本语法如下：

```mysql
ALTER USER user [IDENTIFIED BY '新密码']
[, user[IDENTIFIED BY '新密码']]...;
```

其中，`user`参数表示新用户的账户，由用户名和主机名构成；`IDENTIFIED BY`关键字用来设置密码。

举例：

```mysql
ALTER USER 'gxl'@'localhost' IDENTIFIED BY 'gxl';
```

**2.使用`SET`命令修改普通用户的密码**

`root`用户使用`SET`语句来修改普通用户的密码，`SET`语句代码如下：

```mysql
SET PASSWORD FOR 'username'@'hostname' = 'new_password';
```

其中，`username`参数是普通用户的用户名；`hostname`参数是普通用户的主机名；`new_password`是新密码。

举例：

```mysql
SET PASSWORD FOR 'gxl'@'localhost' = 'gxl';
```

**3.使用`UPDATE`语句修改普通用户的密码（不推荐）**

使用`root`用户登录`MySQL`服务器后，可以使用`UPDATE`语句修改`MySQL`数据库的`user`表的`password`字段，从而修改普通用户的密码。使用`UPDATE`语句修改用户密码的语法如下：

```mysql
UPDATE mysql.user SET authentication_string = PASSWORD('123456')
WHERE User = 'usernmae' AND Host = 'hostname';
```

举例：

```mysql
# 修改某个用户的密码：

# MySQL 5.5
UPDATE mysql.user SET PASSWORD = PASSWORD('123456') WHERE USER = 'li4';

# MySQL 5.7（不适用于 MySQL8）
UPDATE mysql.user SET authentication_string = PASSWORD('123456') WHERE USER = 'li4';
```

`PASSWORD()`函数用来加密用户密码。执行`UPDATE`语句后，需要执行`FLUSH PRIVILEGES`语句重新加载用户权限。

### 1.7 `MySQL8`密码管理（了解）

`MySQL`中记录使用过的历史密码，目前包含如下密码管理功能：

1. 密码过期：要求定期修改密码
2. 密码重用限制：不允许使用旧密码
3. 密码强度评估：要求使用高强度的密码。（第一章有讲）

> 提示：
>
> `MySQL`密码管理功能只针对使用基于`MySQL`权限插件的账号，这些插件有`mysql_native_password`、`sha256_password`、`caching_sha2_password`。

#### 1.7.1 密码过期策略

- 在`MySQL`中，数据库管理员可以==手动设置==帐号密码过期，也可以建立一个==自动==密码过期策略。
- 过期策略可以是==全局的==，也可以为==每个账号==设置单独的过期策略。

**手动设置立马过期**

手动设置账号密码过期，可使用如下语句：

```mysql
ALTER USER user PASSWORD EXPIRE;
```

举例：

```mysql
ALTER USER 'gxl'@'localhost' PASSWORD EXPIRE;
```

该语句将用户`gxl`的密码设置为过期，`gxl`用户仍然可以登录进入数据库，但无法进行查询。密码过期后，只有重新设置了新密码，才能正常使用。

**手动设置指定时间过期方式1：全局**

如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。

`MySQL`使用`default_password_lifetime`系统变量建立全局密码过期策略。

- 它的默认值是`0`，表示禁用自动密码过期。
- 它允许的值是正整数`N`，表示允许的密码生存期。密码必须==每隔N天==进行修改。

两种实现方式分别如图所示：

- **方式①：使用`SQL`语句更改该变量的值并持久化**

```mysql
SET PERSIST default_password_lifetime = 180; # 建立全局策略，设置密码每隔180天过期
```

- **方式②：配置文件`my.cnf`中进行维护**

```properties
[mysqld]
default_password_lifetime=180 # 建立全局策略，设置密码每隔180天过期
```

**手动设置指定时间过期方式2：单独设置**

每个帐号既可沿用全局密码过期策略，也可单独设置策略。在`CREATE USER`和`ALTER USER`语句上加入`PASSWORD EXPIRE`选项可实现单独设置策略。举例：

```mysql
CREATE USER 'gxl'@'localhost' PASSWORD EXPIRE INTERVAL 90 DAY;
ALTER USER 'gxl'@'localhost' PASSWORD EXPIRE INTERVAL 90 DAY;

# 设置密码永不过期
CREATE USER 'gxl'@'localhost' PASSWORD EXPIRE NEVER;
ALTER USER 'gxl'@'localhost' PASSWORD EXPIRE NEVER;

# 沿用全局密码过期策略：
CREATE USER 'gxl'@'localhost' PASSWORD EXPIRE DEFAULT;
ALTER USER 'gxl'@'localhost' PASSWORD EXPIRE DEFAULT;
```

#### 1.7.2 密码重用策略

`MySQL`限制使用已过期的密码。重用限制策略基于==密码更改的数量==和==使用的时间==。重用策略可以是==全局==的，也可以为每个账户设置==单独的策略==。

- 帐号的历史密码包含过去该帐号所使用的密码。`MySQL`基于以下规则来限制密码重用：

  - 如果帐号的密码限制==基于密码更改的数量==，那么新密码不能从最近限制的密码数量中选择。比如，如果密码更改的最小值为`3`，那么新密码不能与最近`3`个密码中任何一个相同。
  - 如果帐号密码限制==基于时间==，那么新密码不能从规定时间内选择。比如，如果密码重用周期为`60`天，那么新密码不能从最近`60`天内使用的密码中选择。

- `MySQL`使用`password_history`和`password_reuse_interval`系统变量设置密码重用策略。

  - `password_history`：规定密码重用的数量
  - `password_reuse_interval`：规定密码重用的周期

- 这两个值可在==服务器的配置文件==中进行维护，也可在运行期间==使用 SQL 语句更改==该变量的值并持久化。

- **手动设置密码重用方式1：全局**

  - **方式①：使用`SQL`**

  ```mysql
  SET PERSIST password_history = 6; # 设置不能选择最近使用过的6个密码
  
  SET PERSIST password_reuse_interval = 365; # 设置不能选择最近一年内的密码
  ```

  - **方式②：`my.cnf`配置文件**

  ```properties
  [mysqld]
  password_history=6
  password_reuse_interval=365
  ```

- **手动设置密码重用方式2：单独设置**

每个账号可以沿用全局密码重用策略，也可单独设置策略。这两个选项可以单独使用，也可以结合在一起使用。示例：

```mysql
# 不能使用最近5个密码：
CREATE USER 'gxl'@'localhost' PASSWORD HISTORY 5;
ALTER USER 'gxl'@'localhost' PASSWORD HISTORY 5;

# 不能使用最近365天内的密码：
CREATE USER 'gxl'@'localhost' PASSWORD REUSE INTERVAL 365 DAY;
ALTER USER 'gxl'@'localhost' PASSWORD REUSE INTERVAL 365 DAY;

# 既不能使用最近5个密码，也不能使用365天内的密码
CREATE USER 'gxl'@'localhost'
PASSWORD HISTORY 5
PASSWORD REUSE INTERVAL 365 DAY;

ALTER USER 'gxl'@'localhost'
PASSWORD HISTORY 5
PASSWORD REUSE INTERVAL 365 DAY;
```

```mysql
# 使用全局策略
CREATE USER 'gxl'@'localhost'
PASSWORD HISTORY DEFAULT
PASSWORD REUSE INTERVAL DEFAULT;

ALTER USER 'gxl'@'localhost'
PASSWORD HISTORY DEFAULT
PASSWORD REUSE INTERVAL DEFAULT;
```

## 2.权限管理

---

关于`MySQL`的权限简单的理解就是`MySQL`允许你做你权利以内的事，不可以越界。比如只允许执行`SELECT`操作，那么你就不能执行`UPDATE`操作。只允许你从某台机器上连接`MySQL`，那么你就不能从除那台机器以外的其他机器连接`MySQL`。

### 2.1 权限列表

`MySQL`到底有哪些权限呢？

```mysql
mysql> show privileges;
```

`GRANT`和`REVOKE`语句中可以使用的权限如下：

| 权限                    | `user`表中对应的列     | 权限的范围           |
| ----------------------- | ---------------------- | -------------------- |
| CREATE                  | Create_priv            | 数据库、表或索引     |
| DROP                    | Drop_priv              | 数据库、表或视图     |
| GRANT_OPTION            | Grant_priv             | 数据库、表或存储过程 |
| REFERENCES              | References_priv        | 数据库或表           |
| EVENT                   | Event_priv             | 数据库               |
| ALTER                   | Alter_priv             | 数据库               |
| DELETE                  | Delete_priv            | 表                   |
| INDEX                   | Index_priv             | 表                   |
| INSERT                  | Insert_priv            | 表                   |
| SELECT                  | Select_priv            | 表或列               |
| UPDATE                  | Update_priv            | 表或列               |
| CREATE TEMPORARY TABLES | Create_tmp_table_priv  | 表                   |
| LOCK TABLES             | Lock_tables_priv       | 表                   |
| TRIGGER                 | Trigger_priv           | 表                   |
| CREATE VIEW             | Create_view_priv       | 视图                 |
| SHOW VIEW               | Show_view_priv         | 视图                 |
| ALTER ROUTINE           | Alter_routine_priv     | 存储过程和函数       |
| CREATE ROUTINE          | Create_routine_priv    | 存储过程和函数       |
| EXECUTE                 | Execute_priv           | 存储过程和函数       |
| FILE                    | File_priv              | 访问服务器上的文件   |
| CREATE TABLESPACE       | Create_tablespace_priv | 服务器管理           |
| CREATE USER             | Create_user_priv       | 服务器管理           |
| PROCESS                 | Process_priv           | 存储过程和函数       |
| RELOAD                  | Reload_priv            | 访问服务器上的文件   |
| REPLICATION_CLIENT      | Repl_client_priv       | 服务器管理           |
| REPLICATION_SLAVE       | Repl_slave_priv        | 服务器管理           |
| SHOW DATABASES          | Show_db_priv           | 服务器管理           |
| SHUTDOWN                | Shutdown_priv          | 服务器管理           |
| SUPER                   | Super_priv             | 服务器管理           |

1. `CREATE`和`DROP`权限，可以创建新的数据库和表，或删除（移除）已有的数据库和表。如果将`MySQL`数据库中的`DROP`权限授予某用户，用户可以删除`MySQL`访问权限保存的数据库。
2. `SELECT、INSERT、UPDATE、DELETE权限`允许在一个数据库现有的表上实施操作。
3. `SELECT`权限只有在它们真正从一个表中检索行时才被使用到。
4. `INDEX权限`运行创建或删除索引。`INDEX`适用于已有表。如果具有某个表的`CREATE`权限，就可以在`CREATE TABLE`语句中包括索引定义。
5. `ALTER权限`可以使用`ALTER TABLE`来更改表的结构和重新命名表。
6. `CREATE ROUTINE权限`用来创建保存的程序（函数和存储过程），`ALTER ROUTINE`权限用来更改和删除保存的程序，`EXECUTE权限`用来执行保存的程序。
7. `GRANT权限`允许授权给其他用户，可用于数据库、表和保存的程序。
8. `FILE权限`使用户可以使用`LOAD DATA INFILE`和`SELECT ... INTO OUTFIEL`语句读或写服务器上的文件，任何被授予`FILE`权限的用户都能读或写`MySQL`服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。

**`MySQL`的权限如何分布**：

| 权限分布 | 可能的设置的权限                                             |
| -------- | ------------------------------------------------------------ |
| 表权限   | SELECT. INSERT, UPDATE, DELETE, CREATE, DROP, GRANT, REFERENCES, INDEX, ALTER |
| 列权限   | SELECT, INSERT, UPDATE, REFERENCES                           |
| 过程权限 | EXECUTE, ALTER ROUTINE, GRANT                                |

### 2.2 授予权限的原则

权限控制主要是出于安全因素，因此需要遵循以下几个==经验原则==：

1. 只授予能==满足需要的最小权限==，防止用户干坏事。比如用户只是需要查询，那么只给`SELECT`权限就可以了，不用给用户赋予`UPDATE`、`INSERT`或`DELETE`权限。

2. 创建用户时==限制用户的登录主机==，一般是限制或指定`IP`或内网`IP`段。
3. 为每个用户==设置满足密码复杂度的密码==。
4. ==定期清理不需要的用户==，回收权限或删除用户。

### 2.3 授予权限

给用户授权的方式有2种，分别是通过把==角色赋予用户给用户授权==和==直接给用户授权==。用户是数据库的使用者，可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。

授权命令：

```mysql
GRANT 权限1,权限2,...权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY '密码口令'];
```

该权限如果发现没有该用户，则会直接创建一个用户。

比如：

- 给`li4`用户用本地命令行方式，授予`atguigudb`这个库下的所有表的插删改查的权限。

```mysql
GRANT SELECT, INSERT, DELETE, UPDATE ON atguigudb.* TO 'li4'@'localhost';
```

- 授予通过网络方式登录的`gxl`用户，对所有库所有表的全部权限，密码设置为`123`。注意这里维度不包含`GRANT`的权限

  ```mysql
  GRANT ALL PRIVILEGES ON *.* TO 'gxl'@'%' IDENTIFIED BY '123';
  ```

  - `ALL PRIVILEGES`是表示所有权限，可以使用`SELECT`、`UPDATE`等权限。
  - `ON`用来指定权限针对哪些库和表
  - `.`前面的`*`号用来指定数据库名，后面的`*`好来指定表名。这里的`*`表示所有的。
  - `TO`表示将权限赋予某些用户。
  - `'gxl'@'localhost'`表示`gxl`用户，`@`后面接限制的主机，可以是`IP`、`IP`段、域名以及`%`，`%`表示任何地方。注意：这里`%`有的版本不包括本地，以前碰到过给某个用户设置了`%`允许任何地方登陆，但是在本地登陆不了，这个和版本有关系，遇到这个问题再加一个`localhost`的用户就可以了。
  - `IDENTIFIED BY`指定用户的登录密码。

- 如果需要赋予包含`GRANT`的权限，添加参数"WITH GRANT OPTION"这个选项即可，表示该用户可以将自己拥有的权限授权给别人。经常有人在创建操作用户的时候不指定`WITH GRANT OPTION`选项导致后来该用户不能使用`GRANT`命令创建用户或给其他用户授权。
- 可以使用`GRANT`重复给用户添加权限，==权限叠加==，比如先给用户添加一个`SELECT`权限，然后又给用户添加一个`INSERT`权限，那么该用户就同时拥有了`SELECT`和`INSERT`权限。

> 在开发应用时，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。
>
> - 所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；
> - 所谓纵向的分组，就是指用户对接触到的数据能访问到什么程序，比如能看、能改、甚至是删除。

### 2.4 查看权限

- 查看当前用户权限

```mysql
SHOW GRANTS;
# 或
SHOW GRANTS FOR CURRENT_USER;
# 或
SHOW GRANTS FOR CURRENT_USER();
```

- 查看某用户的全局权限

```mysql
SHOW GRANTS FOR 'user'@'主机地址';
```

### 2.5 回收权限

收回权限就是取消已经赋予用户的某些权限。**回收用户不必要的权限可以在一定程序上保证系统的安全性**。`MySQL`中使用`REVOKE`语句取消用户的某些权限。使用`REVOKE`收回权限之后，用户账户的记录将从`db`、`host`、`tables_priv`和`columns_priv`表中删除，但是用户账户记录仍然在`user`表中保存（删除`user`表中的账户记录使用`DROP USER`语句）。

**注意：在将用户账户从`user`表删除之后，应该回收相应用户的所有权限**。

- 回收权限命令

```mysql
REVOKE 权限1,权限2,...权限n ON 数据库名称.表名称 FROM 用户名@用户地址;
```

- 举例：

```mysql
# 回收全库全表的所有权限
REVOKE ALL PRIVILEGES ON *.* FROM gxl@'%';

# 回收mysql库下的所有表的增删改查权限
REVOKE SELECT,UPDATE,DELETE,INSERT ON mysql.* FROM gxl@'%';
```

注意：==须用户重新登录后才能生效==

> 总结：
>
> 有些程序员喜欢使用`ROOT`来访问数据库，完全把==权限控制==放在==应用层面==实现。这样当然也是可以的，但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限。不要轻易用`ROOT`帐号。因为`ROOT`帐号密码放在代码里面不安全，一旦泄露，数据库就会完全==失去保护==。

## 3.权限表

---

`MySQL`服务器通过==权限表==来**控制用户对数据库的访问**，权限表存放在`mysql`数据库中。`MySQL`数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是`user表`、`db表`。除此之外，还有`table_priv表`、`column_priv表`和`procs_priv表`等。**在`MySQL`启动时，服务器将这些数据库表中权限信息的内容读入内存**。

| 表名             | 描述                           |
| ---------------- | ------------------------------ |
| user             | 用户帐号及权限信息             |
| global_grants    | 动态全局授权                   |
| db               | 数据库层级的权限               |
| tables_priv      | 表层级的权限                   |
| columns_priv     | 列层级的权限                   |
| procs_priv       | 存储过程和函数权限             |
| proxics_priv     | 代理用户的权限                 |
| default_roles    | 帐号连接并认证后默认授予的角色 |
| role_edges       | 角色子图的边界                 |
| password_history | 密码更改信息                   |

### 3.1 `user`表

`user`表是`MySQL`中最重要的一个权限表，==记录用户帐号和权限信息==，有~~49~~`51`个字段。如下：

```mysql
mysql> desc user;
+--------------------------+-----------------------------------+------+-----+-----------------------+-------+
| Field                    | Type                              | Null | Key | Default               | Extra |
+--------------------------+-----------------------------------+------+-----+-----------------------+-------+
| Host                     | char(255)                         | NO   | PRI |                       |       |
| User                     | char(32)                          | NO   | PRI |                       |       |
| Select_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Insert_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Update_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Delete_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Create_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Drop_priv                | enum('N','Y')                     | NO   |     | N                     |       |
| Reload_priv              | enum('N','Y')                     | NO   |     | N                     |       |
| Shutdown_priv            | enum('N','Y')                     | NO   |     | N                     |       |
| Process_priv             | enum('N','Y')                     | NO   |     | N                     |       |
| File_priv                | enum('N','Y')                     | NO   |     | N                     |       |
| Grant_priv               | enum('N','Y')                     | NO   |     | N                     |       |
| References_priv          | enum('N','Y')                     | NO   |     | N                     |       |
| Index_priv               | enum('N','Y')                     | NO   |     | N                     |       |
| Alter_priv               | enum('N','Y')                     | NO   |     | N                     |       |
| Show_db_priv             | enum('N','Y')                     | NO   |     | N                     |       |
| Super_priv               | enum('N','Y')                     | NO   |     | N                     |       |
| Create_tmp_table_priv    | enum('N','Y')                     | NO   |     | N                     |       |
| Lock_tables_priv         | enum('N','Y')                     | NO   |     | N                     |       |
| Execute_priv             | enum('N','Y')                     | NO   |     | N                     |       |
| Repl_slave_priv          | enum('N','Y')                     | NO   |     | N                     |       |
| Repl_client_priv         | enum('N','Y')                     | NO   |     | N                     |       |
| Create_view_priv         | enum('N','Y')                     | NO   |     | N                     |       |
| Show_view_priv           | enum('N','Y')                     | NO   |     | N                     |       |
| Create_routine_priv      | enum('N','Y')                     | NO   |     | N                     |       |
| Alter_routine_priv       | enum('N','Y')                     | NO   |     | N                     |       |
| Create_user_priv         | enum('N','Y')                     | NO   |     | N                     |       |
| Event_priv               | enum('N','Y')                     | NO   |     | N                     |       |
| Trigger_priv             | enum('N','Y')                     | NO   |     | N                     |       |
| Create_tablespace_priv   | enum('N','Y')                     | NO   |     | N                     |       |
| ssl_type                 | enum('','ANY','X509','SPECIFIED') | NO   |     |                       |       |
| ssl_cipher               | blob                              | NO   |     | NULL                  |       |
| x509_issuer              | blob                              | NO   |     | NULL                  |       |
| x509_subject             | blob                              | NO   |     | NULL                  |       |
| max_questions            | int unsigned                      | NO   |     | 0                     |       |
| max_updates              | int unsigned                      | NO   |     | 0                     |       |
| max_connections          | int unsigned                      | NO   |     | 0                     |       |
| max_user_connections     | int unsigned                      | NO   |     | 0                     |       |
| plugin                   | char(64)                          | NO   |     | caching_sha2_password |       |
| authentication_string    | text                              | YES  |     | NULL                  |       |
| password_expired         | enum('N','Y')                     | NO   |     | N                     |       |
| password_last_changed    | timestamp                         | YES  |     | NULL                  |       |
| password_lifetime        | smallint unsigned                 | YES  |     | NULL                  |       |
| account_locked           | enum('N','Y')                     | NO   |     | N                     |       |
| Create_role_priv         | enum('N','Y')                     | NO   |     | N                     |       |
| Drop_role_priv           | enum('N','Y')                     | NO   |     | N                     |       |
| Password_reuse_history   | smallint unsigned                 | YES  |     | NULL                  |       |
| Password_reuse_time      | smallint unsigned                 | YES  |     | NULL                  |       |
| Password_require_current | enum('N','Y')                     | YES  |     | NULL                  |       |
| User_attributes          | json                              | YES  |     | NULL                  |       |
+--------------------------+-----------------------------------+------+-----+-----------------------+-------+
51 rows in set (0.00 sec)
```

这些字段可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。

**1.范围列（或用户列）**

`user`表的用户列包括`Host、User、authentication_string`，分别表示主机名、用户名和密码。`Host`指明允许访问的`IP`或主机范围，`User`指明允许访问的用户名。其中`User`和`Host`为`User`表的联合主键。**当用户与服务器之间建立连接时，输入的账户信息中的用户名称、主机名和密码必须匹配`User`表中对应的字段，只有3个值都匹配时，才允许连接的建立**。这3个字段的值就是创建账户时保存的账户信息。修改用户密码时，实际就是修改`user`表的`authentication_string`字段的值。

- `Host`：表示连接类型
  - `%`表示所有远程通过`TCP`方式的连接
  - `IP 地址`如（192.168.1.2、127.0.0.1）通过指定`IP`地址进行的`TCP`方式的连接
  - `机器名`通过指定网络中的机器名进行的`TCP`方式的连接
  - `::1`IPv6的本地`IP`地址，等同于`IPv4`的`127.0.0.1`
  - `localhost`本地方式通过命令行方式的连接，比如`mysql -u xxx -p xxx`方式的连接
- `user`：表示用户名，同一用户通过不同方式连接的权限是不一样的。
- `password`：密码
  - 所有密码串通过`password`（明文字符串）生成的密文字符串。`MySQL 8.0`在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的`SHA1`改为了`SHA2`，不可逆。同时加上了`MySQL 5.7`的禁用用户和用户过期的功能，`MySQL`在用户管理方面的功能和安全性都较之前版本大大的增强了。
  - `MySQL 5.7`及之后版本的密码保存到`authentication_string`字段中，不再使用`password`字段。

**2.权限列**

权限列的字段决定用户的权限，描述了在全局范围内允许对数据和数据库进行的操作，包括查询、修改权限等==普通权限==，还包括关闭服务器、超级权限和加载用户等==高级权限==。普通权限用于操作数据库，高级权限用于数据库管理。

`user`表中对应的权限是针对所有用户数据库的。这些字段值的类型为`ENUM`，可以取的值只能是`Y`和`N`，`Y`表示该用户有对应的权限，`N`表示用户没有该权限。从`user`表的结构可以看到，这些字段的值==默认都是N==。如果要修改权限，就可以使用`GRANT`语句或`UPDATE`语句更改`user`表的这些字段来修改用户对应的权限。

- `Grant_priv`字段
  - 表示是否拥有`GRANT`权限
- `Shutdown_priv`字段
  - 表示是否拥有停止`MySQL`服务的权限
- `Super_priv`字段
  - 表示是否拥有超级权限
- `Execute_priv`字段
  - 表示是否拥有`EXECUTE`权限。拥有`EXECUTE`权限，可以执行存储过程和函数
- `Select_priv`,` Insert_priv`等
  - 为该用户所拥有的权限。

**3.安全列**

安全列只有6个字段，其中两个是`ssl`相关的（ssl_tyoe, ssl_cipher），用于==加密==；两个是`x509`相关的（x509_issuer, x509_subject），用于==标识用户==；另外两个`Plugin`字段用于==验证用户身份==的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。

**4.资源控制列**

资源控制列的字段用来==现在用户使用的资源==，包含4个字段，分别为：

①`max_questions`，用户每小时允许执行的查询操作次数

②`max_updates`，用户每小时允许执行的更新操作次数

③`max_connections`，用户每小时允许执行的连接操作次数

④`max_user_connections`，用户允许同时建立的连接次数

**一个小时内用户查询或者连接数量超过资源控制限制，用户将被锁定，直到下一个小时才可以再次执行对应的操作。可以使用`GRANT`语句更新这些字段的值**。

查看字段：

```mysql
DESC mysql.user;
```

查看用户，以列的方式显示数据：

```mysql
SELECT * FROM mysql.user \G
```

查看特定字段：

```mysql
SELECT host, user, authentication_string, select_priv, insert_priv, drop_priv
FROM mysql.user;
```

### 3.2 `db`表

`db`表是`MySQL`数据库中非常重要的权限表。==db表中存储了用户对某个数据库的操作权限==，决定用户能从哪个主机存取哪个数据库，`db`表比较常用。

**`user`表中的权限是针对所有数据库的**，如果`user`表中的`Select_priv`字段值取`Y`，那么该用户可以查询所有数据库中的表。**如果希望用户只针对某个数据库由操作权限，那么需要将`user`表中对应的权限设置为`N`，然后再`db`表中设置对应数据库的操作权限**。由此可知，用户先根据`user`表的内容获取权限，然后根据`db`表的内容获取权限。

使用`DESC`查看`db`表的基本结构，具体`SQL`语句如下：

```mysql
mysql> desc mysql.db;
+-----------------------+---------------+------+-----+---------+-------+
| Field                 | Type          | Null | Key | Default | Extra |
+-----------------------+---------------+------+-----+---------+-------+
| Host                  | char(255)     | NO   | PRI |         |       |
| Db                    | char(64)      | NO   | PRI |         |       |
| User                  | char(32)      | NO   | PRI |         |       |
| Select_priv           | enum('N','Y') | NO   |     | N       |       |
| Insert_priv           | enum('N','Y') | NO   |     | N       |       |
| Update_priv           | enum('N','Y') | NO   |     | N       |       |
| Delete_priv           | enum('N','Y') | NO   |     | N       |       |
| Create_priv           | enum('N','Y') | NO   |     | N       |       |
| Drop_priv             | enum('N','Y') | NO   |     | N       |       |
| Grant_priv            | enum('N','Y') | NO   |     | N       |       |
| References_priv       | enum('N','Y') | NO   |     | N       |       |
| Index_priv            | enum('N','Y') | NO   |     | N       |       |
| Alter_priv            | enum('N','Y') | NO   |     | N       |       |
| Create_tmp_table_priv | enum('N','Y') | NO   |     | N       |       |
| Lock_tables_priv      | enum('N','Y') | NO   |     | N       |       |
| Create_view_priv      | enum('N','Y') | NO   |     | N       |       |
| Show_view_priv        | enum('N','Y') | NO   |     | N       |       |
| Create_routine_priv   | enum('N','Y') | NO   |     | N       |       |
| Alter_routine_priv    | enum('N','Y') | NO   |     | N       |       |
| Execute_priv          | enum('N','Y') | NO   |     | N       |       |
| Event_priv            | enum('N','Y') | NO   |     | N       |       |
| Trigger_priv          | enum('N','Y') | NO   |     | N       |       |
+-----------------------+---------------+------+-----+---------+-------+
22 rows in set (0.01 sec)
```

执行结果显示，`db`表的字段大致可以分为两类，分别为用户列和权限列。

**1.用户列**

`db`表用户列有3个字段，分别是`Host、User、Db`。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了`db`表的主键。

**2.权限列**

`Create_routine_priv`和`Alter_routine_priv`这两个字段决定用户是否具有创建和修改存储过程的权限。

### 3.3 `tables_priv`表和`column_priv`表

`tables_priv`表用来==对表设置操作权限==，`columns_priv`表用来对表的==某一列设置权限==。`tables_priv`表和`columns_priv`表如下：

```mysql
desc mysql.tables_priv;
```

| 字段名      | 数据类型                                                     | 默认值            |
| ----------- | ------------------------------------------------------------ | ----------------- |
| Host        | char(255)                                                    |                   |
| Db          | char(64)                                                     |                   |
| User        | char(32)                                                     |                   |
| Table_name  | char(64)                                                     |                   |
| Grantor     | varchar(88)                                                  |                   |
| Timestamp   | timestamp                                                    | CURRENT_TIMESTAMP |
| Table_priv  | set('Select','Insert','Update','Delete','Create','Drop','Grant','References','Index','Alter','Create View','Show view','Trigger') |                   |
| Column_priv | set(‘Select’,’Insert’,’Update’,’References’)                 |                   |

`tables_priv`表有8个字段，各个字段说明如下：

- `Host、Db、User`和`Table_name`四个字段分别表示主机名、数据库名、用户名和表名。
- `Grantor`表示修改该记录的用户。
- `Timestamp`表示修改该记录的时间。
- `Table_priv`表示对象的操作权限，包括`Select、Insert、Update、Delete、Create、Drop、Grant、References、Index、Alter、Create View、Show view、Trigger`。
- `Column_priv`字段表示对表中的列的操作权限，包括`Select、Insert、Update、References`。

```mysql
mysql> desc mysql.columns_priv;
+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+
| Field       | Type                                         | Null | Key | Default           | Extra                                         |
+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+
| Host        | char(255)                                    | NO   | PRI |                   |                                               |
| Db          | char(64)                                     | NO   | PRI |                   |                                               |
| User        | char(32)                                     | NO   | PRI |                   |                                               |
| Table_name  | char(64)                                     | NO   | PRI |                   |                                               |
| Column_name | char(64)                                     | NO   | PRI |                   |                                               |
| Timestamp   | timestamp                                    | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
| Column_priv | set('Select','Insert','Update','References') | NO   |     |                   |                                               |
+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+
7 rows in set (0.00 sec)
```

`columns_priv`表只有7个字段，分别是`Host、Db、User、Table_name、Column_name、Timestamp、Column_priv`。其中，`Column_name`用来指定对哪些数据列具有操作权限。

### 3.4 `procs_priv`表

`procs_priv`表可以对==存储过程和存储函数设置操作权限==。表结构如下：

```mysql
mysql> desc mysql.procs_priv;
+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+
| Field        | Type                                   | Null | Key | Default           | Extra                                         |
+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+
| Host         | char(255)                              | NO   | PRI |                   |                                               |
| Db           | char(64)                               | NO   | PRI |                   |                                               |
| User         | char(32)                               | NO   | PRI |                   |                                               |
| Routine_name | char(64)                               | NO   | PRI |                   |                                               |
| Routine_type | enum('FUNCTION','PROCEDURE')           | NO   | PRI | NULL              |                                               |
| Grantor      | varchar(288)                           | NO   | MUL |                   |                                               |
| Proc_priv    | set('Execute','Alter Routine','Grant') | NO   |     |                   |                                               |
| Timestamp    | timestamp                              | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+
8 rows in set (0.01 sec)
```

`procs_priv`表包含8个字段。

- `Host、Db`和`User`字段分别表示主机名、数据库名和用户名。
- `Routine_name`表示存储过程或函数的名称。
- `Routine_type`表示存储过程或函数的类型。`Routine_type`字段有两个值，分别是`FUNCTION`和`PROCEDURE`：`FUNCTION`表示存储函数，另外一个表示存储过程。
- `Grantor`是插入或删除该记录的用户。
- `Proc_priv`表示拥有的权限，包括`Execute、Alter Routine、Grant`三种。
- `Timestamp`表示记录更新时间。

## 4.访问控制（了解）

---

正常情况下，并不希望每个用户都可以执行所有的数据库操作。当`MySQL`允许一个用户执行各种操作时，它将首先核实该用户向`MySQL`服务器发送的连接请求，然后确认用户的操作请求是否被允许。这个过程称为`MySQL`中的==访问控制过程==。`MySQL`的访问控制分为两个阶段：==连接核实阶段==和==请求核实阶段==。

### 4.1 连接核实阶段

当用户试图连接`MySQL`服务时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，`MySQL`服务器接收到用户请求后，会**使用`user`表中的`Host、User`和`authentication_string`这3个字段匹配客户端提供信息**。

服务器只有在`user`表记录的`Host`和`User`字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。**如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求**。

### 4.2 请求核实阶段

一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自`user、db、tables_priv`和`columns_priv`表。

确认权限时，`MySQL`首先==检查user表==，如果指定的权限没有在`user`表中被授予，那么`MySQL`就会继续==检查db表==，`db`表是下一安全层级，其中的权限限定与数据库层级，在该层级的`SELECT`权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则`MySQL`继续==检查tables_priv表==以及==columns_priv表==，如果所有权限表都检查完毕，但还是没找到允许的权限操作，`MySQL`将==返回错误信息==，用户请求的操作不能执行，操作失败。请求核实过程如图所示：

![image-20220605125707225](第03章_用户与权限管理.assets\image-20220605125707225.png)

>提示：
>
>`MySQL`通过向下层级的顺序（从`user`表到`columns_priv`表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到`MySQL`服务器之后只执行对`MySQL`的管理操作，此时只涉及管理权限，因此`MySQL`只检查`user`表。另外，如果请求的权限操作不被允许，`MySQL`也不会继续检查下一层级的表。

## 5.角色管理

---

### 5.1 角色的理解

角色是在`MySQL 8.0`中引入的新功能。在`MySQL`中，==角色是权限的集合==，可以为角色添加或移除权限。用户可以被赋予角色，同时也被赋予角色包含的权限。对角色进行操作需要较高的权限。并且像用户账户一样，角色可以拥有授予和撤销的权限。

引入角色的目的是==方便管理拥有相同权限的用户==。**恰当的权限设定，可以确保数据的安全性，这是至关重要的**。

![image-20220605130552677](第03章_用户与权限管理.assets\image-20220605130552677.png)

### 5.2 创建角色

在实际应用中，为了安全性，需要给用户授予权限。当用户数量较多时，为了避免单独给每一个用户授予多个权限，可以先将权限集合放入角色中，再赋予用户相应的角色。

创建角色使用`CREATE ROLE`语句，语法如下：

```mysql
CREATE ROLE 'role_name'[@'host_name'][, 'role_name'[@'host_name']]...;
```

角色名称的命名规则和用户名类似。如果`host_name`省略，默认为`%`，`role_name`不可省略，不可为空。

举例：

```mysql
CREATE ROLE 'manager'@'localhost';
```

创建一个角色，角色名称为"manager"，角色可以登录的主机是"localhost"，只能从数据库服务器运行的这台计算机上登录该帐号。不写主机名，直接创建角色"manager"：

```mysql
CREATE ROLE 'manager';
```

不写主机名，`MySQL`默认是通配符"%"，意思是这个帐号可以从任何一台主机上登录数据库。

一次性创建3个角色：

```mysql
CREATE ROLE 'app_developer', 'app_read', 'app_write';
```

### 5.3 给角色赋予权限

创建角色后，默认这个角色没有任何权限的，我们需要给角色授权。授权语法结构是：

```mysql
GRANT privileges ON table_name TO 'role_name'[@'host_name'];
```

上述语句中`privileges`代表权限的名称，多个权限以逗号隔开。可使用`SHOW`语句查询权限名称

```mysql
SHOW PRIVILEGES \G
```

举例：

```mysql
GRANT SELECT ON demo.settlement TO 'manager';
```

如果需要赋予库管角色盘点表的增删查改权限、商品信息的只读权限，对应付款表没有权限，可以这样写：

```mysql
GRANT SELECT, UPDATE, INSERT, DELETE ON demo.invcount TO 'stocker';

GRANT SELECT ON demo.goodmaster TO 'stocker';
```

举例2：

```mysql
GRANT ALL PRIVILEGES ON app_db.* TO 'app_developer';

GRANT SELECT ON app_db.* TO 'app_read';
```

### 5.4 查看角色的权限

赋予角色权限之后，可以通过`SHOW GRANTS`语句，查看权限是否创建成功了：

```mysql
mysql> show grants for 'manager';
+---------------------------------------------------------------------------+
| Grants for manager@%                                                      |
+---------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO `manager`@`%`                                       |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `dbtest1`.`emp1` TO `manager`@`%` |
+---------------------------------------------------------------------------+
2 rows in set (0.00 sec)
```

只要创建了一个角色，系统就会自动给你一个`USAGE`权限，意思是==连接登录数据库的权限==。

### 5.5 回收角色的权限

角色授权后，可以对角色权限进行维护，对权限进行添加或撤销。添加权限使用`GRANT`语句，与角色授权相同。撤销角色或角色权限使用`REVOKE`语句。

修改了角色的权限，会影响拥有该角色的账户的权限。

撤销角色权限的`SQL`语句如下：

```mysql
REVOKE privileges ON tablename FROM 'rolename';
```

举例：撤销`school_write`角色的权限

```mysql
REVOKE INSERT, UPDATE, DELETE ON school.* FROM 'school_write';

SHOW GRANTS FOR 'school_write';
```

### 5.6 删除角色

需要对业务重新整合时，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角色。删除角色的语法结构：

```mysql
DROP ROLE role[, role2]...;
```

注意：==删除角色后，那么用户也就失去了通过这个角色所获得的所有权限==。

举例：

```mysql
DROP ROLE 'school_read';
```

### 5.7 给用户赋予角色

角色创建并授权后，要赋给用户并处于==激活状态==才能发挥作用。给用户添加角色可使用`GRANT`语句，语法如下：

```mysql
GRANT role[, role2, ...] TO user[, user2, ...];
```

`role`代表角色，`user`代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。

举例：给`wangwu`用户添加角色`manager`权限。

```mysql
GRANT 'manager' TO 'wangwu'@'%';

SHOW GRANTS FOR 'wangwu'@'%'; 

# 3.使用wangwu用户登录，查看当前角色，如果角色未激活，结果将显示NONE
mysql> SELECT CURRENT_ROLE();
+----------------+
| CURRENT_ROLE() |
+----------------+
| NONE           |
+----------------+
1 row in set (0.00 sec)
```

说明用户未具备相应的角色。

或用赋予了角色的用户去登录、操作，这个帐号没有任何权限。这是因为，**`MySQL`中创建了角色之后，默认都是没有被激活**，也就是不能用，必须要==手动激活==，激活之后用户才能拥有角色对应的权限。

### 5.8 激活角色

**方式1：使用`SET DEFAULT ROLE`命令激活角色**

举例：

```mysql
SET DEFAULT ROLE ALL/具体角色 TO 'wangwu'@'%';
```

> 注意：用户需要退出重新登录，才能看到赋予的角色。

**方式2：将`activate all roles on login`设置为`ON`**

- 默认情况：

```mysql
mysql> show variables like 'activate_all_roles_on_login';
+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| activate_all_roles_on_login | OFF   |
+-----------------------------+-------+
1 row in set (0.00 sec)
```

- 设置

```mysql
SET GLOBAL activate_all_roles_on_login=ON;
```

运行这条语句之后，用户才真正拥有了赋予角色的所有权限。

查看当前会话已激活的角色：

```mysql
SELECT CURRENT_ROLE();
```

### 5.9 撤销用户的角色

撤销用户的`SQL`语法如下：

```mysql
REVOKE role FROM user;
```

举例：撤销`wangwu`用户的`manager`角色。

```mysql
REVOKE 'manager'@'%' FROM 'wangwu'@'%';

SHOW GRANTS FOR 'wangwu';
```

### 5.10 设置强制角色（mandatory role）

强制角色是给每个创建账户的默认角色，不需要手动设置。强制角色无法被`REVOKE`或`DROP`。

方式1：服务器启动前设置

```properties
[mysqld]
mandatory_roles='role1,role2@localhost,r3@%.atguigu.com'
```

方式2：运行时设置

```mysql
SET PERSIST mandatory_roles = 'role1,role2@localhost,r3@%.example.com';
SET GLOBAL mandatory_roles = 'role1,role2@localhost,r3@%.example.com';
```

### 5.11 小结

`MySQL`主要管理角色的语句如下：

|                          语句                          |                    作用                    |
| :----------------------------------------------------: | :----------------------------------------: |
|               CREATE ROLE and DROP ROLE                |               创建和删除角色               |
|                    GRANT and REVOKE                    |            给角色或账户分配权限            |
|                      SHOW GRANTS                       |     显示 账户/角色 所拥有的 权限或角色     |
|                    SET DEFAULT ROLE                    |          设置账户默认使用什么角色          |
|                        SET ROLE                        |             改变当前会话的角色             |
|               SELECT CURRENT_ROLE()函数                |             显示当前会话的角色             |
| mandatory_role 和 activate_all_roles_on_login 系统变量 | 允许定义用户登录时强制的或者激活授权的角色 |

## 6.配置文件的使用

---

### 6.1 配置文件格式

与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号`[]`括起来：

```properties
[server]
(具体的启动选项...)

[mysqld]
(具体的启动选项...)

[mysqld_safe]
...

[client]
...

[mysql]
...

[mysqladmin]
...
```

像这个配置文件里就定义了许多组，组名分别是`server、mysqld、mysqld_safe、client、mysql、mysqladmin`。每个组下边可以定义若干个启动选项，我们以`[server]`组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：

```properties
[server]
option1			# 这是 option1，该选项不需要选项值
option2=value2	# 该选项需要选项值
...
```

在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中指定的启动选项不允许加`--`前缀，并且每行只指定一个选项，而且`=`周围不可以有空白字符（命令行中选项名、`=`、选项值之间不允许有空白字符）。另外，在配置文件中，可以使用`#`添加注释，从`#`出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。

### 6.2 启动命令与选项组

配置文件中不同的选项组是给不同的启动命令使用的。有两个选项组比较特别：

- `[server]`组下的启动选项将作用于==所有的服务器==程序。
- `[client]`组下的启动选项将作用于==所有的客户端==程序。

| 启动命令     | 类别       | 能读取的组                         |
| ------------ | ---------- | ---------------------------------- |
| mysqld       | 启动服务器 | [mysqld]、[server]                 |
| mysqld_safe  | 启动服务器 | [mysqld]、[server]、[mysqld_safe]  |
| mysql.server | 启动服务器 | [mysqld]、[server]、[mysql.server] |
| mysql        | 启动客户端 | [mysql]、[client]                  |
| mysqladmin   | 启动客户端 | [mysqladmin]、[client]             |
| mysqldump    | 启动客户端 | [mysqldump]、[client]              |

比如，在`/etc/my.cnf`这个配置文件中添加一些内容：

```properties
[server]
skip-networking
default-storage-engine=MyISAM
```

然后直接用`mysqld`启动服务器程序：

```powershell
mysqld
```

虽然在命令行没有添加启动选项，但是在程序启动时，就会默认到我们上边提到的配置文件路径下查找配置文件，其中就包括`/etc/my.cnf`。又由于`mysqld`命令可以读取`[server]`选项组的内容，所以`skip-networking`和`default-storage-engine=MyISAM`都生效了。如果把这些启动选项放在`[client]`组里面再试试`mysqld`启动服务器程序，就不生效了。

### 6.3 特定`MySQL`版本的专用选项组

可以在选项组的名称后加上特定的`MySQL`版本号，比如对于`[mysqld]`选项组来说，可以定义一个`mysqld-5.7`的选项组，它的含义和`[mysqld]`一样，只不过只有版本号为`5.7`的`mysqld`程序才能使用这个选项组中的选项。

### 6.4 同一个配置文件中多个组的优先级

同一命令可以访问配置文件中的多个组，比如`mysqld`可以访问`[mysqld]`、`[server]`组，如果在同一个配置文件中，比如`~/my.cnf`，这些组里出现了相同的配置项，比如：

```properties
[server]
default-storage-engine=InnoDB

[mysqld]
default-storage-engine=MyISAM
```

那么，将以最后一个出现的组中的启动选项为准，比方说例子中`default-storage-engine`既出现在`[mysqld]`组，也出现在`[server]`组，因为`[mysqld]`组在`[server]`组后面，就以`[mysqld]`组中的配置项为准。

### 6.5 命令行和配置文件中启动选项的区别

在命令行上指定的绝大部分启动选项都可以放在配置文件中，但有些选项是专门为命令行设计的，比方说`defaults-extra-file`、`defaults-file`这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没什么意义了。

如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以==命令行中的启动选项为准==！比如我们在配置文件中写了：

```properties
[server]
default-storage-engine=InnoDB
```

启动命令：

```powershell
mysql.server start --default-storage-engine=MyISAM
```

最后`default-storage-engine`的值是`MyISAM`。

## 7.系统变量（复习）

---

### 7.1 系统变量简介

`MySQL`服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为`MySQL`系统变量。比如：

- `max_connections`：允许同时连如的客户端数量
- `default_storage_engine`：表的默认存储引擎用系统变量
- `query_cache_size`：查询缓存的大小

### 7.2 查看系统变量

查看`MySQL`服务器程序支持的系统变量以及它们的当前值：

```mysql
# 查看所有全局变量
SHOW GLOBAL VARIABLES;

# 查看所有会话变量
SHOW SESSION VARIABLES;
# 或
SHOW VARIABLES;
```

```mysql
# 查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE '%标识符%';

# 查看满足条件的部分会话系统变量
SHOW SESSION VARIABLES LIKE '%标识符%';
```

### 7.3 设置系统变量

#### 7.3.1 通过启动选项设置

大部分系统变量都可以通过启动服务器时传送启动选项的方式来进行设置。如何填写启动选项？总结一下：

- **通过命令行添加启动选项**

  ```powershell
  mysqld --default-storage-engine=MyISAM --max-connections=10
  ```

- **通过配置文件添加启动选项**

  ```properties
  [server]
  default-storage-engine=MyISAM
  max-connections=10
  ```

当使用上边两种方式中的任意一种启动服务器程序后，查看系统变量的值：

```mysql
mysql> show variables like 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)
```

看到`default_storage_engine`和`max_connections`这两个系统变量的值已经被修改了。有一点需要注意的是，对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线`-`或者下划线`_`连接起来都可以，但是它对应的系统变量的单词之间必须使用下划线`_`连接起来。

#### 7.3.2 服务器程序运行过程中设置

对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器，但是，系统变量有作用范围之分。

**设置不同作用范围的系统变量**

多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值。比方说客户端`A`，他想让当前客户端对应的默认存储引擎为`InnoDB`，所以他可以把系统变量`default_storage_engine`的值设置为`InnoDB`；客户端`B`，他想让当前客户端对应的默认存储引擎为`MyISAM`，所以他可以把系统变量`default_storage_engine`的值设置为`MyISAM`。这样两个客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题：

- 有些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量`max_connections`，查询缓存的大小`query_cache_size`，这些公有的系统变量让某个客户端私有显然不合适。
- 一个新链接到服务器的客户端对应的系统变量的值该怎么设置？

为了解决这两个问题，`MySQL`提出了系统变量作用范围概念，具体来说作用范围分为这两种：

- `GLOBAL`：全局变量，影响服务器的整体操作
- `SESSION`：会话变量，影响某个客户端连接的操作。（注：`SESSION`有个别名叫`LOCAL`）

在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令行或选项文件中指定的选项更改这些默认值）、然后服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值初始化。

以`default_storage_engine`举例，在服务器启动时会初始化一个名为`default_storage_engine`，作用范围为`GLOBAL`的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为`default_storage_engine`，作用范围为`SESSION`的系统变量，该作用范围为`SESSION`的系统变量值按照当前作用范围为`GLOBAL`的同名系统变量值进行初始化。

很显然，通过启动选项设置的系统变量的作用范围都是`GLOBAL`的，也就是对所有客户端都有效的，因为在系统启动时还没有客户端程序连接进来呢。了解了系统变量的`GLOBAL`和`SESSION`作用范围之后，我们再看一下在服务器程序运行期间通过客户端程序设置系统变量的语法：

```mysql
SET [GLOBAL|SESSION] 系统变量名 = 值;
```

或者写成这样也行：

```mysql
SET [@@(GLOBAL|SESSION).]var_name = xxx;
```

比如，服务器运行过程中把作用范围为`GLOBAL`的系统变量`default_storage_engine`的值修改为`MyISAM`，也就是想让之后新连接到服务器的客户端都用`MyISAM`作为默认的存储引擎，那我们可以选择下边两条语句中的任意一条来进行设置：

```mysql
# 方式1：
SET GLOBAL default_storage_engine = MyISAM;

# 方式2：
SET @@GLOBAL.default_storage_engine = MyISAM;
```

如果只想对本客户端生效，也可以选择如下任意一条来进行设置：

```mysql
# 方式1：
SET SESSION default_storage_engine = MyISAM;

# 方式2：
SET @@SESSION.default_storage_engine = MyISAM;

# 方式3：
SET default_storage_engine = MyISAM;
```

**查看不同作用范围的系统变量**

既然系统变量有作用范围之分，那我们的`SHOW VARIABLES`语句查看的是什么作用范围的系统变量呢？

答：默认查看的是`SESSION`作用范围的系统变量。

我们也可以在查看系统变量的语句上加上要查看哪个==作用范围==的系统变量：

```mysql
SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的格式];
```

> PS: 如果某个客户端改变了某个系统变量在`GLOBAL`作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为`SESSION`的值，只会影响后续连入的客户端在作用范围为`SESSION`的值。

**注意事项**

并不是所有系统变量都具有`GLOBAL`和`SESSION`的作用范围。

- 有些系统变量只具有`GLOBAL`作用范围，比方说`max_connections`，表示服务器程序支持同时最多有多少个客户端程序进行连接。

- 有些系统变量只具有`SESSION`作用范围，比如`insert_id`，表示在对某个包含`AUTO_INCREMENT`列的表进行插入时，该列初始的值。

- 有些系统变量的值既具有`GLOBAL`作用范围，也具有`SESSION`作用范围，比如`default_storage_engine`，而且其实大部分系统变量都这样。

- 有些系统变量是只读的，并不能设置值。

  比如说`version`，表示当前`MySQL`版本，我们客户端是不能设置它的值的，只能在`SHOW VARIABLES`语句里查看。
